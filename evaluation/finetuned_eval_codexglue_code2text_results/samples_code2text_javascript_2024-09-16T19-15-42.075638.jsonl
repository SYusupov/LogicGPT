{"doc_id": 0, "doc": {"id": 0, "repo": "axios/axios", "path": "lib/axios.js", "func_name": "createInstance", "original_string": "function createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}", "language": "javascript", "code": "function createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}", "code_tokens": ["function", "createInstance", "(", "defaultConfig", ")", "{", "var", "context", "=", "new", "Axios", "(", "defaultConfig", ")", ";", "var", "instance", "=", "bind", "(", "Axios", ".", "prototype", ".", "request", ",", "context", ")", ";", "// Copy axios.prototype to instance", "utils", ".", "extend", "(", "instance", ",", "Axios", ".", "prototype", ",", "context", ")", ";", "// Copy context to instance", "utils", ".", "extend", "(", "instance", ",", "context", ")", ";", "return", "instance", ";", "}"], "docstring": "Create an instance of Axios\n\n@param {Object} defaultConfig The default config for the instance\n@return {Axios} A new instance of Axios", "docstring_tokens": ["Create", "an", "instance", "of", "Axios"], "sha": "92d231387fe2092f8736bc1746d4caa766b675f5", "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/axios.js#L15-L26"}, "target": "Create an instance of Axios", "arguments": {"gen_args_0": {"arg_0": "function createInstance ( defaultConfig ) { var context = new Axios ( defaultConfig ) ; var instance = bind ( Axios . prototype . request , context ) ; // Copy axios.prototype to instance utils . extend ( instance , Axios . prototype , context ) ; // Copy context to instance utils . extend ( instance , context ) ; return instance ; }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function bind ( fn , ctx ) { var self = this ; var"]], "filtered_resps": ["function bind ( fn , ctx ) { var self = this ; var"], "doc_hash": "b28c767a3916d509701a6914e99603aa134e23cdf754de30204fc8ee4091c8b2", "prompt_hash": "9510d08d51e7ce5541dff1eda9b34f164806ec0d1a007a5ce6aa2844ed026cd9", "target_hash": "0346deb313c65646bc29d4603cebe8f137d1fef4ca816f589968d3d170f68b8d", "smoothed_bleu_4": 9.236149212030169e-77}
{"doc_id": 1, "doc": {"id": 1, "repo": "axios/axios", "path": "lib/cancel/CancelToken.js", "func_name": "CancelToken", "original_string": "function CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}", "language": "javascript", "code": "function CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}", "code_tokens": ["function", "CancelToken", "(", "executor", ")", "{", "if", "(", "typeof", "executor", "!==", "'function'", ")", "{", "throw", "new", "TypeError", "(", "'executor must be a function.'", ")", ";", "}", "var", "resolvePromise", ";", "this", ".", "promise", "=", "new", "Promise", "(", "function", "promiseExecutor", "(", "resolve", ")", "{", "resolvePromise", "=", "resolve", ";", "}", ")", ";", "var", "token", "=", "this", ";", "executor", "(", "function", "cancel", "(", "message", ")", "{", "if", "(", "token", ".", "reason", ")", "{", "// Cancellation has already been requested", "return", ";", "}", "token", ".", "reason", "=", "new", "Cancel", "(", "message", ")", ";", "resolvePromise", "(", "token", ".", "reason", ")", ";", "}", ")", ";", "}"], "docstring": "A `CancelToken` is an object that can be used to request cancellation of an operation.\n\n@class\n@param {Function} executor The executor function.", "docstring_tokens": ["A", "CancelToken", "is", "an", "object", "that", "can", "be", "used", "to", "request", "cancellation", "of", "an", "operation", "."], "sha": "92d231387fe2092f8736bc1746d4caa766b675f5", "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/cancel/CancelToken.js#L11-L31"}, "target": "A CancelToken is an object that can be used to request cancellation of an operation .", "arguments": {"gen_args_0": {"arg_0": "function CancelToken ( executor ) { if ( typeof executor !== 'function' ) { throw new TypeError ( 'executor must be a function.' ) ; } var resolvePromise ; this . promise = new Promise ( function promiseExecutor ( resolve ) { resolvePromise = resolve ; } ) ; var token = this ; executor ( function cancel ( message ) { if ( token . reason ) { // Cancellation has already been requested return ; } token . reason = new Cancel ( message ) ; resolvePromise ( token . reason ) ; } ) ; }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["CancelToken.prototype . toString = function () { return this . promise"]], "filtered_resps": ["CancelToken.prototype . toString = function () { return this . promise"], "doc_hash": "1f707982c45bfe0ef1ed9378b7eea8a1f0096c8a0b05fe35c086542fa47799b5", "prompt_hash": "67e4af7efc09cce50eca71f9215ec64db2fe2879e188315dcdb7353caa43964c", "target_hash": "7c6b019bf207fec005c7257470235819f01c4ebd4da09c27606510c89ff2b92f", "smoothed_bleu_4": 7.870573891449917}
{"doc_id": 2, "doc": {"id": 2, "repo": "axios/axios", "path": "lib/utils.js", "func_name": "isArrayBufferView", "original_string": "function isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}", "language": "javascript", "code": "function isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}", "code_tokens": ["function", "isArrayBufferView", "(", "val", ")", "{", "var", "result", ";", "if", "(", "(", "typeof", "ArrayBuffer", "!==", "'undefined'", ")", "&&", "(", "ArrayBuffer", ".", "isView", ")", ")", "{", "result", "=", "ArrayBuffer", ".", "isView", "(", "val", ")", ";", "}", "else", "{", "result", "=", "(", "val", ")", "&&", "(", "val", ".", "buffer", ")", "&&", "(", "val", ".", "buffer", "instanceof", "ArrayBuffer", ")", ";", "}", "return", "result", ";", "}"], "docstring": "Determine if a value is a view on an ArrayBuffer\n\n@param {Object} val The value to test\n@returns {boolean} True if value is a view on an ArrayBuffer, otherwise false", "docstring_tokens": ["Determine", "if", "a", "value", "is", "a", "view", "on", "an", "ArrayBuffer"], "sha": "92d231387fe2092f8736bc1746d4caa766b675f5", "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/utils.js#L48-L56"}, "target": "Determine if a value is a view on an ArrayBuffer", "arguments": {"gen_args_0": {"arg_0": "function isArrayBufferView ( val ) { var result ; if ( ( typeof ArrayBuffer !== 'undefined' ) && ( ArrayBuffer . isView ) ) { result = ArrayBuffer . isView ( val ) ; } else { result = ( val ) && ( val . buffer ) && ( val . buffer instanceof ArrayBuffer ) ; } return result ; }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function isDataView ( val ) { var result ; if ( ("]], "filtered_resps": ["function isDataView ( val ) { var result ; if ( ("], "doc_hash": "ce1c4fa23b2124868cb0bb17bd9d0e687e62702a4287e5b3874dac54cad89895", "prompt_hash": "f13def6da26685aa632750933a349493ac8a17e9281017aed354ccc7dc4d9db4", "target_hash": "8de6324ab957f3a7fb55463fd8a867833c37235ca42e3383638c2ff1f5226b00", "smoothed_bleu_4": 8.913765521398126}
{"doc_id": 3, "doc": {"id": 3, "repo": "axios/axios", "path": "lib/utils.js", "func_name": "isStandardBrowserEnv", "original_string": "function isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}", "language": "javascript", "code": "function isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}", "code_tokens": ["function", "isStandardBrowserEnv", "(", ")", "{", "if", "(", "typeof", "navigator", "!==", "'undefined'", "&&", "(", "navigator", ".", "product", "===", "'ReactNative'", "||", "navigator", ".", "product", "===", "'NativeScript'", "||", "navigator", ".", "product", "===", "'NS'", ")", ")", "{", "return", "false", ";", "}", "return", "(", "typeof", "window", "!==", "'undefined'", "&&", "typeof", "document", "!==", "'undefined'", ")", ";", "}"], "docstring": "Determine if we're running in a standard browser environment\n\nThis allows axios to run in a web worker, and react-native.\nBoth environments support XMLHttpRequest, but not fully standard globals.\n\nweb workers:\ntypeof window -> undefined\ntypeof document -> undefined\n\nreact-native:\nnavigator.product -> 'ReactNative'\nnativescript\nnavigator.product -> 'NativeScript' or 'NS'", "docstring_tokens": ["Determine", "if", "we", "re", "running", "in", "a", "standard", "browser", "environment"], "sha": "92d231387fe2092f8736bc1746d4caa766b675f5", "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/utils.js#L183-L193"}, "target": "Determine if we re running in a standard browser environment", "arguments": {"gen_args_0": {"arg_0": "function isStandardBrowserEnv ( ) { if ( typeof navigator !== 'undefined' && ( navigator . product === 'ReactNative' || navigator . product === 'NativeScript' || navigator . product === 'NS' ) ) { return false ; } return ( typeof window !== 'undefined' && typeof document !== 'undefined' ) ; }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function isWebWorkerEnv ( ) { return typeof importScripts !=="]], "filtered_resps": ["function isWebWorkerEnv ( ) { return typeof importScripts !=="], "doc_hash": "360e62fe30130e638fde4ea68d78566c47786b447e5988cdba7b6acec152dac8", "prompt_hash": "e83df20f1f65c3e5de31bf856a5fd70222343f74a10a8e2374cd426e41fd0a2d", "target_hash": "4638c7cd7b36e140239ac7f7ab1961f868094fd45d28ac3e78f0900af483fdcd", "smoothed_bleu_4": 1.1955813667911344e-76}
{"doc_id": 4, "doc": {"id": 4, "repo": "axios/axios", "path": "lib/utils.js", "func_name": "forEach", "original_string": "function forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}", "language": "javascript", "code": "function forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}", "code_tokens": ["function", "forEach", "(", "obj", ",", "fn", ")", "{", "// Don't bother if no value provided", "if", "(", "obj", "===", "null", "||", "typeof", "obj", "===", "'undefined'", ")", "{", "return", ";", "}", "// Force an array if not already something iterable", "if", "(", "typeof", "obj", "!==", "'object'", ")", "{", "/*eslint no-param-reassign:0*/", "obj", "=", "[", "obj", "]", ";", "}", "if", "(", "isArray", "(", "obj", ")", ")", "{", "// Iterate over array values", "for", "(", "var", "i", "=", "0", ",", "l", "=", "obj", ".", "length", ";", "i", "<", "l", ";", "i", "++", ")", "{", "fn", ".", "call", "(", "null", ",", "obj", "[", "i", "]", ",", "i", ",", "obj", ")", ";", "}", "}", "else", "{", "// Iterate over object keys", "for", "(", "var", "key", "in", "obj", ")", "{", "if", "(", "Object", ".", "prototype", ".", "hasOwnProperty", ".", "call", "(", "obj", ",", "key", ")", ")", "{", "fn", ".", "call", "(", "null", ",", "obj", "[", "key", "]", ",", "key", ",", "obj", ")", ";", "}", "}", "}", "}"], "docstring": "Iterate over an Array or an Object invoking a function for each item.\n\nIf `obj` is an Array callback will be called passing\nthe value, index, and complete array for each item.\n\nIf 'obj' is an Object callback will be called passing\nthe value, key, and complete object for each property.\n\n@param {Object|Array} obj The object to iterate\n@param {Function} fn The callback to invoke for each item", "docstring_tokens": ["Iterate", "over", "an", "Array", "or", "an", "Object", "invoking", "a", "function", "for", "each", "item", "."], "sha": "92d231387fe2092f8736bc1746d4caa766b675f5", "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/utils.js#L207-L232"}, "target": "Iterate over an Array or an Object invoking a function for each item .", "arguments": {"gen_args_0": {"arg_0": "function forEach ( obj , fn ) { // Don't bother if no value provided if ( obj === null || typeof obj === 'undefined' ) { return ; } // Force an array if not already something iterable if ( typeof obj !== 'object' ) { /*eslint no-param-reassign:0*/ obj = [ obj ] ; } if ( isArray ( obj ) ) { // Iterate over array values for ( var i = 0 , l = obj . length ; i < l ; i ++ ) { fn . call ( null , obj [ i ] , i , obj ) ; } } else { // Iterate over object keys for ( var key in obj ) { if ( Object . prototype . hasOwnProperty . call ( obj , key ) ) { fn . call ( null , obj [ key ] , key , obj ) ; } } } }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function isArray ( val ) { return Array . isArray ? Array"]], "filtered_resps": ["function isArray ( val ) { return Array . isArray ? Array"], "doc_hash": "df7937b57729800e572947877c62e2bb83b2cd626a1b7aacfe8e7b275a2de3a6", "prompt_hash": "7b19763ae4e00f083c6e307aeb3d07c34b80b2b3da9ba3b3a445b18b8671ac85", "target_hash": "48ff9ec70c08c6cc474ed0fb3133fd3a852d5fb4e92fbe6cc68d6690ebed501a", "smoothed_bleu_4": 10.05835555876797}
{"doc_id": 5, "doc": {"id": 5, "repo": "axios/axios", "path": "lib/utils.js", "func_name": "extend", "original_string": "function extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}", "language": "javascript", "code": "function extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}", "code_tokens": ["function", "extend", "(", "a", ",", "b", ",", "thisArg", ")", "{", "forEach", "(", "b", ",", "function", "assignValue", "(", "val", ",", "key", ")", "{", "if", "(", "thisArg", "&&", "typeof", "val", "===", "'function'", ")", "{", "a", "[", "key", "]", "=", "bind", "(", "val", ",", "thisArg", ")", ";", "}", "else", "{", "a", "[", "key", "]", "=", "val", ";", "}", "}", ")", ";", "return", "a", ";", "}"], "docstring": "Extends object a by mutably adding to it the properties of object b.\n\n@param {Object} a The object to be extended\n@param {Object} b The object to copy properties from\n@param {Object} thisArg The object to bind function to\n@return {Object} The resulting value of object a", "docstring_tokens": ["Extends", "object", "a", "by", "mutably", "adding", "to", "it", "the", "properties", "of", "object", "b", "."], "sha": "92d231387fe2092f8736bc1746d4caa766b675f5", "url": "https://github.com/axios/axios/blob/92d231387fe2092f8736bc1746d4caa766b675f5/lib/utils.js#L301-L310"}, "target": "Extends object a by mutably adding to it the properties of object b .", "arguments": {"gen_args_0": {"arg_0": "function extend ( a , b , thisArg ) { forEach ( b , function assignValue ( val , key ) { if ( thisArg && typeof val === 'function' ) { a [ key ] = bind ( val , thisArg ) ; } else { a [ key ] = val ; } } ) ; return a ; }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function forEach ( obj , callback ) { for ( var key in"]], "filtered_resps": ["function forEach ( obj , callback ) { for ( var key in"], "doc_hash": "8322026e7d86c9d5c325c179002c9443b1d96d5cdd1e628d39fbdcdb28740be1", "prompt_hash": "8a58274049cfbb06bde55493edf7a29ef0b5612bca6330a6e6d05391a1af11fc", "target_hash": "1b208dca24813f00dd2072c9c5c4367c983a83bc46ddbdf47cbec7a5636bcaa3", "smoothed_bleu_4": 9.304647277988532e-77}
{"doc_id": 6, "doc": {"id": 6, "repo": "zeit/next.js", "path": "packages/next/taskfile-ncc.js", "func_name": "writePackageManifest", "original_string": "function writePackageManifest (packageName) {\n  const packagePath = require.resolve(packageName + '/package.json')\n  let { name, main, author, license, types, typings } = require(packagePath)\n  if (!main) {\n    main = 'index.js'\n  }\n\n  let typesFile = types || typings\n  if (typesFile) {\n    typesFile = require.resolve(join(packageName, typesFile))\n  }\n\n  const compiledPackagePath = join(__dirname, `dist/compiled/${packageName}`)\n\n  const potentialLicensePath = join(dirname(packagePath), './LICENSE')\n  if (existsSync(potentialLicensePath)) {\n    this._.files.push({\n      dir: compiledPackagePath,\n      base: 'LICENSE',\n      data: readFileSync(potentialLicensePath, 'utf8')\n    })\n  }\n\n  this._.files.push({\n    dir: compiledPackagePath,\n    base: 'package.json',\n    data:\n      JSON.stringify(\n        Object.assign(\n          {},\n          { name, main: `${basename(main, '.' + extname(main))}` },\n          author ? { author } : undefined,\n          license ? { license } : undefined,\n          typesFile\n            ? {\n              types: relative(compiledPackagePath, typesFile)\n            }\n            : undefined\n        )\n      ) + '\\n'\n  })\n}", "language": "javascript", "code": "function writePackageManifest (packageName) {\n  const packagePath = require.resolve(packageName + '/package.json')\n  let { name, main, author, license, types, typings } = require(packagePath)\n  if (!main) {\n    main = 'index.js'\n  }\n\n  let typesFile = types || typings\n  if (typesFile) {\n    typesFile = require.resolve(join(packageName, typesFile))\n  }\n\n  const compiledPackagePath = join(__dirname, `dist/compiled/${packageName}`)\n\n  const potentialLicensePath = join(dirname(packagePath), './LICENSE')\n  if (existsSync(potentialLicensePath)) {\n    this._.files.push({\n      dir: compiledPackagePath,\n      base: 'LICENSE',\n      data: readFileSync(potentialLicensePath, 'utf8')\n    })\n  }\n\n  this._.files.push({\n    dir: compiledPackagePath,\n    base: 'package.json',\n    data:\n      JSON.stringify(\n        Object.assign(\n          {},\n          { name, main: `${basename(main, '.' + extname(main))}` },\n          author ? { author } : undefined,\n          license ? { license } : undefined,\n          typesFile\n            ? {\n              types: relative(compiledPackagePath, typesFile)\n            }\n            : undefined\n        )\n      ) + '\\n'\n  })\n}", "code_tokens": ["function", "writePackageManifest", "(", "packageName", ")", "{", "const", "packagePath", "=", "require", ".", "resolve", "(", "packageName", "+", "'/package.json'", ")", "let", "{", "name", ",", "main", ",", "author", ",", "license", ",", "types", ",", "typings", "}", "=", "require", "(", "packagePath", ")", "if", "(", "!", "main", ")", "{", "main", "=", "'index.js'", "}", "let", "typesFile", "=", "types", "||", "typings", "if", "(", "typesFile", ")", "{", "typesFile", "=", "require", ".", "resolve", "(", "join", "(", "packageName", ",", "typesFile", ")", ")", "}", "const", "compiledPackagePath", "=", "join", "(", "__dirname", ",", "`", "${", "packageName", "}", "`", ")", "const", "potentialLicensePath", "=", "join", "(", "dirname", "(", "packagePath", ")", ",", "'./LICENSE'", ")", "if", "(", "existsSync", "(", "potentialLicensePath", ")", ")", "{", "this", ".", "_", ".", "files", ".", "push", "(", "{", "dir", ":", "compiledPackagePath", ",", "base", ":", "'LICENSE'", ",", "data", ":", "readFileSync", "(", "potentialLicensePath", ",", "'utf8'", ")", "}", ")", "}", "this", ".", "_", ".", "files", ".", "push", "(", "{", "dir", ":", "compiledPackagePath", ",", "base", ":", "'package.json'", ",", "data", ":", "JSON", ".", "stringify", "(", "Object", ".", "assign", "(", "{", "}", ",", "{", "name", ",", "main", ":", "`", "${", "basename", "(", "main", ",", "'.'", "+", "extname", "(", "main", ")", ")", "}", "`", "}", ",", "author", "?", "{", "author", "}", ":", "undefined", ",", "license", "?", "{", "license", "}", ":", "undefined", ",", "typesFile", "?", "{", "types", ":", "relative", "(", "compiledPackagePath", ",", "typesFile", ")", "}", ":", "undefined", ")", ")", "+", "'\\n'", "}", ")", "}"], "docstring": "This function writes a minimal `package.json` file for a compiled package. It defines `name`, `main`, `author`, and `license`. It also defines `types`. n.b. types intended for development usage only.", "docstring_tokens": ["This", "function", "writes", "a", "minimal", "package", ".", "json", "file", "for", "a", "compiled", "package", ".", "It", "defines", "name", "main", "author", "and", "license", ".", "It", "also", "defines", "types", ".", "n", ".", "b", ".", "types", "intended", "for", "development", "usage", "only", "."], "sha": "3641f79a0f68d1093cc238b50b8d47eec1c25cfd", "url": "https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/taskfile-ncc.js#L34-L75"}, "target": "This function writes a minimal package . json file for a compiled package . It defines name main author and license . It also defines types . n . b . types intended for development usage only .", "arguments": {"gen_args_0": {"arg_0": "function writePackageManifest ( packageName ) { const packagePath = require . resolve ( packageName + '/package.json' ) let { name , main , author , license , types , typings } = require ( packagePath ) if ( ! main ) { main = 'index.js' } let typesFile = types || typings if ( typesFile ) { typesFile = require . resolve ( join ( packageName , typesFile ) ) } const compiledPackagePath = join ( __dirname , ` ${ packageName } ` ) const potentialLicensePath = join ( dirname ( packagePath ) , './LICENSE' ) if ( existsSync ( potentialLicensePath ) ) { this . _ . files . push ( { dir : compiledPackagePath , base : 'LICENSE' , data : readFileSync ( potentialLicensePath , 'utf8' ) } ) } this . _ . files . push ( { dir : compiledPackagePath , base : 'package.json' , data : JSON . stringify ( Object . assign ( { } , { name , main : ` ${ basename ( main , '.' + extname ( main ) ) } ` } , author ? { author } : undefined , license ? { license } : undefined , typesFile ? { types : relative ( compiledPackagePath , typesFile ) } : undefined ) ) + '\\n' } ) }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [[""]], "filtered_resps": [""], "doc_hash": "4f3e35d0688a2f6628b0c0a097bbbe496aebef7e57658c2b369c6c31ad43d3a0", "prompt_hash": "79bc41f0179f9951ecc833fa327cc697e1819d1b4b3cb34c14bc5d6cc8410246", "target_hash": "a92811c3e94975033c8ceb17a437cec23d04c395a856fb49e37b5916cfc105b4", "smoothed_bleu_4": 3.1391327920480297e-15}
{"doc_id": 7, "doc": {"id": 7, "repo": "zeit/next.js", "path": "packages/next/client/dev-error-overlay/hot-dev-client.js", "func_name": "processMessage", "original_string": "function processMessage (e) {\n  const obj = JSON.parse(e.data)\n  switch (obj.action) {\n    case 'building': {\n      console.log(\n        '[HMR] bundle ' + (obj.name ? \"'\" + obj.name + \"' \" : '') +\n        'rebuilding'\n      )\n      break\n    }\n    case 'built':\n    case 'sync': {\n      clearOutdatedErrors()\n\n      if (obj.hash) {\n        handleAvailableHash(obj.hash)\n      }\n\n      if (obj.warnings.length > 0) {\n        handleWarnings(obj.warnings)\n      }\n\n      if (obj.errors.length > 0) {\n        // When there is a compilation error coming from SSR we have to reload the page on next successful compile\n        if (obj.action === 'sync') {\n          hadRuntimeError = true\n        }\n        handleErrors(obj.errors)\n        break\n      }\n\n      handleSuccess()\n      break\n    }\n    default: {\n      if (customHmrEventHandler) {\n        customHmrEventHandler(obj)\n        break\n      }\n      break\n    }\n  }\n}", "language": "javascript", "code": "function processMessage (e) {\n  const obj = JSON.parse(e.data)\n  switch (obj.action) {\n    case 'building': {\n      console.log(\n        '[HMR] bundle ' + (obj.name ? \"'\" + obj.name + \"' \" : '') +\n        'rebuilding'\n      )\n      break\n    }\n    case 'built':\n    case 'sync': {\n      clearOutdatedErrors()\n\n      if (obj.hash) {\n        handleAvailableHash(obj.hash)\n      }\n\n      if (obj.warnings.length > 0) {\n        handleWarnings(obj.warnings)\n      }\n\n      if (obj.errors.length > 0) {\n        // When there is a compilation error coming from SSR we have to reload the page on next successful compile\n        if (obj.action === 'sync') {\n          hadRuntimeError = true\n        }\n        handleErrors(obj.errors)\n        break\n      }\n\n      handleSuccess()\n      break\n    }\n    default: {\n      if (customHmrEventHandler) {\n        customHmrEventHandler(obj)\n        break\n      }\n      break\n    }\n  }\n}", "code_tokens": ["function", "processMessage", "(", "e", ")", "{", "const", "obj", "=", "JSON", ".", "parse", "(", "e", ".", "data", ")", "switch", "(", "obj", ".", "action", ")", "{", "case", "'building'", ":", "{", "console", ".", "log", "(", "'[HMR] bundle '", "+", "(", "obj", ".", "name", "?", "\"'\"", "+", "obj", ".", "name", "+", "\"' \"", ":", "''", ")", "+", "'rebuilding'", ")", "break", "}", "case", "'built'", ":", "case", "'sync'", ":", "{", "clearOutdatedErrors", "(", ")", "if", "(", "obj", ".", "hash", ")", "{", "handleAvailableHash", "(", "obj", ".", "hash", ")", "}", "if", "(", "obj", ".", "warnings", ".", "length", ">", "0", ")", "{", "handleWarnings", "(", "obj", ".", "warnings", ")", "}", "if", "(", "obj", ".", "errors", ".", "length", ">", "0", ")", "{", "// When there is a compilation error coming from SSR we have to reload the page on next successful compile", "if", "(", "obj", ".", "action", "===", "'sync'", ")", "{", "hadRuntimeError", "=", "true", "}", "handleErrors", "(", "obj", ".", "errors", ")", "break", "}", "handleSuccess", "(", ")", "break", "}", "default", ":", "{", "if", "(", "customHmrEventHandler", ")", "{", "customHmrEventHandler", "(", "obj", ")", "break", "}", "break", "}", "}", "}"], "docstring": "Handle messages from the server.", "docstring_tokens": ["Handle", "messages", "from", "the", "server", "."], "sha": "3641f79a0f68d1093cc238b50b8d47eec1c25cfd", "url": "https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/dev-error-overlay/hot-dev-client.js#L202-L244"}, "target": "Handle messages from the server .", "arguments": {"gen_args_0": {"arg_0": "function processMessage ( e ) { const obj = JSON . parse ( e . data ) switch ( obj . action ) { case 'building' : { console . log ( '[HMR] bundle ' + ( obj . name ? \"'\" + obj . name + \"' \" : '' ) + 'rebuilding' ) break } case 'built' : case 'sync' : { clearOutdatedErrors ( ) if ( obj . hash ) { handleAvailableHash ( obj . hash ) } if ( obj . warnings . length > 0 ) { handleWarnings ( obj . warnings ) } if ( obj . errors . length > 0 ) { // When there is a compilation error coming from SSR we have to reload the page on next successful compile if ( obj . action === 'sync' ) { hadRuntimeError = true } handleErrors ( obj . errors ) break } handleSuccess ( ) break } default : { if ( customHmrEventHandler ) { customHmrEventHandler ( obj ) break } break } } }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function clearOutdatedErrors ( ) { const outdatedErrors = Object . entries"]], "filtered_resps": ["function clearOutdatedErrors ( ) { const outdatedErrors = Object . entries"], "doc_hash": "17c9066b8b3af1f17c15abad80beddde314a6c42bba68b85301b0e49d4613b2f", "prompt_hash": "25f9950d212618031395f0623e8d2fc60d0c6d3af790e30e970f20503bb208ea", "target_hash": "2a6121d6d41b936d5947f5c5e3114a458c69a9e11ced7d30876e2fff7bac3e4b", "smoothed_bleu_4": 9.789105973615678}
{"doc_id": 8, "doc": {"id": 8, "repo": "zeit/next.js", "path": "packages/next/client/dev-error-overlay/hot-dev-client.js", "func_name": "tryApplyUpdates", "original_string": "async function tryApplyUpdates (onHotUpdateSuccess) {\n  if (!module.hot) {\n    // HotModuleReplacementPlugin is not in Webpack configuration.\n    console.error('HotModuleReplacementPlugin is not in Webpack configuration.')\n    // window.location.reload();\n    return\n  }\n\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    return\n  }\n\n  function handleApplyUpdates (err, updatedModules) {\n    if (err || hadRuntimeError) {\n      if (err) {\n        console.warn('Error while applying updates, reloading page', err)\n      }\n      if (hadRuntimeError) {\n        console.warn('Had runtime error previously, reloading page')\n      }\n      window.location.reload()\n      return\n    }\n\n    if (typeof onHotUpdateSuccess === 'function') {\n      // Maybe we want to do something.\n      onHotUpdateSuccess()\n    }\n\n    if (isUpdateAvailable()) {\n      // While we were updating, there was a new update! Do it again.\n      tryApplyUpdates()\n    }\n  }\n\n  // https://webpack.github.io/docs/hot-module-replacement.html#check\n  try {\n    const updatedModules = await module.hot.check(/* autoApply */ {\n      ignoreUnaccepted: true\n    })\n    if (updatedModules) {\n      handleApplyUpdates(null, updatedModules)\n    }\n  } catch (err) {\n    handleApplyUpdates(err, null)\n  }\n}", "language": "javascript", "code": "async function tryApplyUpdates (onHotUpdateSuccess) {\n  if (!module.hot) {\n    // HotModuleReplacementPlugin is not in Webpack configuration.\n    console.error('HotModuleReplacementPlugin is not in Webpack configuration.')\n    // window.location.reload();\n    return\n  }\n\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    return\n  }\n\n  function handleApplyUpdates (err, updatedModules) {\n    if (err || hadRuntimeError) {\n      if (err) {\n        console.warn('Error while applying updates, reloading page', err)\n      }\n      if (hadRuntimeError) {\n        console.warn('Had runtime error previously, reloading page')\n      }\n      window.location.reload()\n      return\n    }\n\n    if (typeof onHotUpdateSuccess === 'function') {\n      // Maybe we want to do something.\n      onHotUpdateSuccess()\n    }\n\n    if (isUpdateAvailable()) {\n      // While we were updating, there was a new update! Do it again.\n      tryApplyUpdates()\n    }\n  }\n\n  // https://webpack.github.io/docs/hot-module-replacement.html#check\n  try {\n    const updatedModules = await module.hot.check(/* autoApply */ {\n      ignoreUnaccepted: true\n    })\n    if (updatedModules) {\n      handleApplyUpdates(null, updatedModules)\n    }\n  } catch (err) {\n    handleApplyUpdates(err, null)\n  }\n}", "code_tokens": ["async", "function", "tryApplyUpdates", "(", "onHotUpdateSuccess", ")", "{", "if", "(", "!", "module", ".", "hot", ")", "{", "// HotModuleReplacementPlugin is not in Webpack configuration.", "console", ".", "error", "(", "'HotModuleReplacementPlugin is not in Webpack configuration.'", ")", "// window.location.reload();", "return", "}", "if", "(", "!", "isUpdateAvailable", "(", ")", "||", "!", "canApplyUpdates", "(", ")", ")", "{", "return", "}", "function", "handleApplyUpdates", "(", "err", ",", "updatedModules", ")", "{", "if", "(", "err", "||", "hadRuntimeError", ")", "{", "if", "(", "err", ")", "{", "console", ".", "warn", "(", "'Error while applying updates, reloading page'", ",", "err", ")", "}", "if", "(", "hadRuntimeError", ")", "{", "console", ".", "warn", "(", "'Had runtime error previously, reloading page'", ")", "}", "window", ".", "location", ".", "reload", "(", ")", "return", "}", "if", "(", "typeof", "onHotUpdateSuccess", "===", "'function'", ")", "{", "// Maybe we want to do something.", "onHotUpdateSuccess", "(", ")", "}", "if", "(", "isUpdateAvailable", "(", ")", ")", "{", "// While we were updating, there was a new update! Do it again.", "tryApplyUpdates", "(", ")", "}", "}", "// https://webpack.github.io/docs/hot-module-replacement.html#check", "try", "{", "const", "updatedModules", "=", "await", "module", ".", "hot", ".", "check", "(", "/* autoApply */", "{", "ignoreUnaccepted", ":", "true", "}", ")", "if", "(", "updatedModules", ")", "{", "handleApplyUpdates", "(", "null", ",", "updatedModules", ")", "}", "}", "catch", "(", "err", ")", "{", "handleApplyUpdates", "(", "err", ",", "null", ")", "}", "}"], "docstring": "Attempt to update code on the fly, fall back to a hard reload.", "docstring_tokens": ["Attempt", "to", "update", "code", "on", "the", "fly", "fall", "back", "to", "a", "hard", "reload", "."], "sha": "3641f79a0f68d1093cc238b50b8d47eec1c25cfd", "url": "https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/dev-error-overlay/hot-dev-client.js#L260-L306"}, "target": "Attempt to update code on the fly fall back to a hard reload .", "arguments": {"gen_args_0": {"arg_0": "async function tryApplyUpdates ( onHotUpdateSuccess ) { if ( ! module . hot ) { // HotModuleReplacementPlugin is not in Webpack configuration. console . error ( 'HotModuleReplacementPlugin is not in Webpack configuration.' ) // window.location.reload(); return } if ( ! isUpdateAvailable ( ) || ! canApplyUpdates ( ) ) { return } function handleApplyUpdates ( err , updatedModules ) { if ( err || hadRuntimeError ) { if ( err ) { console . warn ( 'Error while applying updates, reloading page' , err ) } if ( hadRuntimeError ) { console . warn ( 'Had runtime error previously, reloading page' ) } window . location . reload ( ) return } if ( typeof onHotUpdateSuccess === 'function' ) { // Maybe we want to do something. onHotUpdateSuccess ( ) } if ( isUpdateAvailable ( ) ) { // While we were updating, there was a new update! Do it again. tryApplyUpdates ( ) } } // https://webpack.github.io/docs/hot-module-replacement.html#check try { const updatedModules = await module . hot . check ( /* autoApply */ { ignoreUnaccepted : true } ) if ( updatedModules ) { handleApplyUpdates ( null , updatedModules ) } } catch ( err ) { handleApplyUpdates ( err , null ) } }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function isUpdateAvailable ( ) { return module . hot . status === 'accept"]], "filtered_resps": ["function isUpdateAvailable ( ) { return module . hot . status === 'accept"], "doc_hash": "a9fafe857897a23d0be021cfc14df99100c8d744711d2899cddb6679f6efb71e", "prompt_hash": "ca2e597fb9481f149a62f441400660929e29c0d512a6bc2b531f0d3758dc7f84", "target_hash": "8e3dd6ab80c4a925200f4bc961eb1dc1b03b8e13529d27efe3b16c7eff14d46b", "smoothed_bleu_4": 6.567274736060397}
{"doc_id": 9, "doc": {"id": 9, "repo": "zeit/next.js", "path": "packages/next/client/amp-dev.js", "func_name": "tryApplyUpdates", "original_string": "async function tryApplyUpdates () {\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    return\n  }\n  try {\n    const res = await fetch(`${hotUpdatePath}${curHash}.hot-update.json`)\n    const data = await res.json()\n    const curPage = page === '/' ? 'index' : page\n    const pageUpdated = Object.keys(data.c)\n      .some(mod => {\n        return (\n          mod.indexOf(`pages${curPage.substr(0, 1) === '/' ? curPage : `/${curPage}`}`) !== -1 ||\n          mod.indexOf(`pages${curPage.substr(0, 1) === '/' ? curPage : `/${curPage}`}`.replace(/\\//g, '\\\\')) !== -1\n        )\n      })\n\n    if (pageUpdated) {\n      document.location.reload(true)\n    } else {\n      curHash = mostRecentHash\n    }\n  } catch (err) {\n    console.error('Error occurred checking for update', err)\n    document.location.reload(true)\n  }\n}", "language": "javascript", "code": "async function tryApplyUpdates () {\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\n    return\n  }\n  try {\n    const res = await fetch(`${hotUpdatePath}${curHash}.hot-update.json`)\n    const data = await res.json()\n    const curPage = page === '/' ? 'index' : page\n    const pageUpdated = Object.keys(data.c)\n      .some(mod => {\n        return (\n          mod.indexOf(`pages${curPage.substr(0, 1) === '/' ? curPage : `/${curPage}`}`) !== -1 ||\n          mod.indexOf(`pages${curPage.substr(0, 1) === '/' ? curPage : `/${curPage}`}`.replace(/\\//g, '\\\\')) !== -1\n        )\n      })\n\n    if (pageUpdated) {\n      document.location.reload(true)\n    } else {\n      curHash = mostRecentHash\n    }\n  } catch (err) {\n    console.error('Error occurred checking for update', err)\n    document.location.reload(true)\n  }\n}", "code_tokens": ["async", "function", "tryApplyUpdates", "(", ")", "{", "if", "(", "!", "isUpdateAvailable", "(", ")", "||", "!", "canApplyUpdates", "(", ")", ")", "{", "return", "}", "try", "{", "const", "res", "=", "await", "fetch", "(", "`", "${", "hotUpdatePath", "}", "${", "curHash", "}", "`", ")", "const", "data", "=", "await", "res", ".", "json", "(", ")", "const", "curPage", "=", "page", "===", "'/'", "?", "'index'", ":", "page", "const", "pageUpdated", "=", "Object", ".", "keys", "(", "data", ".", "c", ")", ".", "some", "(", "mod", "=>", "{", "return", "(", "mod", ".", "indexOf", "(", "`", "${", "curPage", ".", "substr", "(", "0", ",", "1", ")", "===", "'/'", "?", "curPage", ":", "`", "${", "curPage", "}", "`", "}", "`", ")", "!==", "-", "1", "||", "mod", ".", "indexOf", "(", "`", "${", "curPage", ".", "substr", "(", "0", ",", "1", ")", "===", "'/'", "?", "curPage", ":", "`", "${", "curPage", "}", "`", "}", "`", ".", "replace", "(", "/", "\\/", "/", "g", ",", "'\\\\'", ")", ")", "!==", "-", "1", ")", "}", ")", "if", "(", "pageUpdated", ")", "{", "document", ".", "location", ".", "reload", "(", "true", ")", "}", "else", "{", "curHash", "=", "mostRecentHash", "}", "}", "catch", "(", "err", ")", "{", "console", ".", "error", "(", "'Error occurred checking for update'", ",", "err", ")", "document", ".", "location", ".", "reload", "(", "true", ")", "}", "}"], "docstring": "This function reads code updates on the fly and hard reloads the page when it has changed.", "docstring_tokens": ["This", "function", "reads", "code", "updates", "on", "the", "fly", "and", "hard", "reloads", "the", "page", "when", "it", "has", "changed", "."], "sha": "3641f79a0f68d1093cc238b50b8d47eec1c25cfd", "url": "https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/amp-dev.js#L34-L59"}, "target": "This function reads code updates on the fly and hard reloads the page when it has changed .", "arguments": {"gen_args_0": {"arg_0": "async function tryApplyUpdates ( ) { if ( ! isUpdateAvailable ( ) || ! canApplyUpdates ( ) ) { return } try { const res = await fetch ( ` ${ hotUpdatePath } ${ curHash } ` ) const data = await res . json ( ) const curPage = page === '/' ? 'index' : page const pageUpdated = Object . keys ( data . c ) . some ( mod => { return ( mod . indexOf ( ` ${ curPage . substr ( 0 , 1 ) === '/' ? curPage : ` ${ curPage } ` } ` ) !== - 1 || mod . indexOf ( ` ${ curPage . substr ( 0 , 1 ) === '/' ? curPage : ` ${ curPage } ` } ` . replace ( / \\/ / g , '\\\\' ) ) !== - 1 ) } ) if ( pageUpdated ) { document . location . reload ( true ) } else { curHash = mostRecentHash } } catch ( err ) { console . error ( 'Error occurred checking for update' , err ) document . location . reload ( true ) } }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [[""]], "filtered_resps": [""], "doc_hash": "c1e060fb8e05741e3b43487449faa3df6bc35459d3c9a16d3c3baecc5bf2b5b6", "prompt_hash": "b999dac9cf827ccd1b7c4f71be2bebfd2b632ae55bed85f93026c23aea07114e", "target_hash": "0de8f2df32b94788184f909d2036078cace719b4783b7fce07f5c15911b94978", "smoothed_bleu_4": 1.522997974471263e-06}
{"doc_id": 10, "doc": {"id": 10, "repo": "zeit/next.js", "path": "packages/next/client/dev-error-overlay/format-webpack-messages.js", "func_name": "formatMessage", "original_string": "function formatMessage (message, isError) {\n  let lines = message.split('\\n')\n\n  // Strip Webpack-added headers off errors/warnings\n  // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js\n  lines = lines.filter(line => !/Module [A-z ]+\\(from/.test(line))\n\n  // Transform parsing error into syntax error\n  // TODO: move this to our ESLint formatter?\n  lines = lines.map(line => {\n    const parsingError = /Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$/.exec(\n      line\n    )\n    if (!parsingError) {\n      return line\n    }\n    const [, errorLine, errorColumn, errorMessage] = parsingError\n    return `${friendlySyntaxErrorLabel} ${errorMessage} (${errorLine}:${errorColumn})`\n  })\n\n  message = lines.join('\\n')\n  // Smoosh syntax errors (commonly found in CSS)\n  message = message.replace(\n    /SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n/g,\n    `${friendlySyntaxErrorLabel} $3 ($1:$2)\\n`\n  )\n  // Remove columns from ESLint formatter output (we added these for more\n  // accurate syntax errors)\n  message = message.replace(/Line (\\d+):\\d+:/g, 'Line $1:')\n  // Clean up export errors\n  message = message.replace(\n    /^.*export '(.+?)' was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$1' is not exported from '$2'.`\n  )\n  message = message.replace(\n    /^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$2' does not contain a default export (imported as '$1').`\n  )\n  message = message.replace(\n    /^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$1' is not exported from '$3' (imported as '$2').`\n  )\n  lines = message.split('\\n')\n\n  // Remove leading newline\n  if (lines.length > 2 && lines[1].trim() === '') {\n    lines.splice(1, 1)\n  }\n  // Clean up file name\n  lines[0] = lines[0].replace(/^(.*) \\d+:\\d+-\\d+$/, '$1')\n\n  // Cleans up verbose \"module not found\" messages for files and packages.\n  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {\n    lines = [\n      lines[0],\n      lines[1]\n        .replace('Error: ', '')\n        .replace('Module not found: Cannot find file:', 'Cannot find file:')\n    ]\n  }\n\n  message = lines.join('\\n')\n  // Internal stacks are generally useless so we strip them... with the\n  // exception of stacks containing `webpack:` because they're normally\n  // from user code generated by Webpack. For more information see\n  // https://github.com/facebook/create-react-app/pull/1050\n  message = message.replace(\n    /^\\s*at\\s((?!webpack:).)*:\\d+:\\d+[\\s)]*(\\n|$)/gm,\n    ''\n  ) // at ... ...:x:y\n  message = message.replace(/^\\s*at\\s<anonymous>(\\n|$)/gm, '') // at <anonymous>\n  lines = message.split('\\n')\n\n  // Remove duplicated newlines\n  lines = lines.filter(\n    (line, index, arr) =>\n      index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim()\n  )\n\n  // Reassemble the message\n  message = lines.join('\\n')\n  return message.trim()\n}", "language": "javascript", "code": "function formatMessage (message, isError) {\n  let lines = message.split('\\n')\n\n  // Strip Webpack-added headers off errors/warnings\n  // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js\n  lines = lines.filter(line => !/Module [A-z ]+\\(from/.test(line))\n\n  // Transform parsing error into syntax error\n  // TODO: move this to our ESLint formatter?\n  lines = lines.map(line => {\n    const parsingError = /Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$/.exec(\n      line\n    )\n    if (!parsingError) {\n      return line\n    }\n    const [, errorLine, errorColumn, errorMessage] = parsingError\n    return `${friendlySyntaxErrorLabel} ${errorMessage} (${errorLine}:${errorColumn})`\n  })\n\n  message = lines.join('\\n')\n  // Smoosh syntax errors (commonly found in CSS)\n  message = message.replace(\n    /SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n/g,\n    `${friendlySyntaxErrorLabel} $3 ($1:$2)\\n`\n  )\n  // Remove columns from ESLint formatter output (we added these for more\n  // accurate syntax errors)\n  message = message.replace(/Line (\\d+):\\d+:/g, 'Line $1:')\n  // Clean up export errors\n  message = message.replace(\n    /^.*export '(.+?)' was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$1' is not exported from '$2'.`\n  )\n  message = message.replace(\n    /^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$2' does not contain a default export (imported as '$1').`\n  )\n  message = message.replace(\n    /^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$/gm,\n    `Attempted import error: '$1' is not exported from '$3' (imported as '$2').`\n  )\n  lines = message.split('\\n')\n\n  // Remove leading newline\n  if (lines.length > 2 && lines[1].trim() === '') {\n    lines.splice(1, 1)\n  }\n  // Clean up file name\n  lines[0] = lines[0].replace(/^(.*) \\d+:\\d+-\\d+$/, '$1')\n\n  // Cleans up verbose \"module not found\" messages for files and packages.\n  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {\n    lines = [\n      lines[0],\n      lines[1]\n        .replace('Error: ', '')\n        .replace('Module not found: Cannot find file:', 'Cannot find file:')\n    ]\n  }\n\n  message = lines.join('\\n')\n  // Internal stacks are generally useless so we strip them... with the\n  // exception of stacks containing `webpack:` because they're normally\n  // from user code generated by Webpack. For more information see\n  // https://github.com/facebook/create-react-app/pull/1050\n  message = message.replace(\n    /^\\s*at\\s((?!webpack:).)*:\\d+:\\d+[\\s)]*(\\n|$)/gm,\n    ''\n  ) // at ... ...:x:y\n  message = message.replace(/^\\s*at\\s<anonymous>(\\n|$)/gm, '') // at <anonymous>\n  lines = message.split('\\n')\n\n  // Remove duplicated newlines\n  lines = lines.filter(\n    (line, index, arr) =>\n      index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim()\n  )\n\n  // Reassemble the message\n  message = lines.join('\\n')\n  return message.trim()\n}", "code_tokens": ["function", "formatMessage", "(", "message", ",", "isError", ")", "{", "let", "lines", "=", "message", ".", "split", "(", "'\\n'", ")", "// Strip Webpack-added headers off errors/warnings", "// https://github.com/webpack/webpack/blob/master/lib/ModuleError.js", "lines", "=", "lines", ".", "filter", "(", "line", "=>", "!", "/", "Module [A-z ]+\\(from", "/", ".", "test", "(", "line", ")", ")", "// Transform parsing error into syntax error", "// TODO: move this to our ESLint formatter?", "lines", "=", "lines", ".", "map", "(", "line", "=>", "{", "const", "parsingError", "=", "/", "Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$", "/", ".", "exec", "(", "line", ")", "if", "(", "!", "parsingError", ")", "{", "return", "line", "}", "const", "[", ",", "errorLine", ",", "errorColumn", ",", "errorMessage", "]", "=", "parsingError", "return", "`", "${", "friendlySyntaxErrorLabel", "}", "${", "errorMessage", "}", "${", "errorLine", "}", "${", "errorColumn", "}", "`", "}", ")", "message", "=", "lines", ".", "join", "(", "'\\n'", ")", "// Smoosh syntax errors (commonly found in CSS)", "message", "=", "message", ".", "replace", "(", "/", "SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n", "/", "g", ",", "`", "${", "friendlySyntaxErrorLabel", "}", "\\n", "`", ")", "// Remove columns from ESLint formatter output (we added these for more", "// accurate syntax errors)", "message", "=", "message", ".", "replace", "(", "/", "Line (\\d+):\\d+:", "/", "g", ",", "'Line $1:'", ")", "// Clean up export errors", "message", "=", "message", ".", "replace", "(", "/", "^.*export '(.+?)' was not found in '(.+?)'.*$", "/", "gm", ",", "`", "`", ")", "message", "=", "message", ".", "replace", "(", "/", "^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$", "/", "gm", ",", "`", "`", ")", "message", "=", "message", ".", "replace", "(", "/", "^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$", "/", "gm", ",", "`", "`", ")", "lines", "=", "message", ".", "split", "(", "'\\n'", ")", "// Remove leading newline", "if", "(", "lines", ".", "length", ">", "2", "&&", "lines", "[", "1", "]", ".", "trim", "(", ")", "===", "''", ")", "{", "lines", ".", "splice", "(", "1", ",", "1", ")", "}", "// Clean up file name", "lines", "[", "0", "]", "=", "lines", "[", "0", "]", ".", "replace", "(", "/", "^(.*) \\d+:\\d+-\\d+$", "/", ",", "'$1'", ")", "// Cleans up verbose \"module not found\" messages for files and packages.", "if", "(", "lines", "[", "1", "]", "&&", "lines", "[", "1", "]", ".", "indexOf", "(", "'Module not found: '", ")", "===", "0", ")", "{", "lines", "=", "[", "lines", "[", "0", "]", ",", "lines", "[", "1", "]", ".", "replace", "(", "'Error: '", ",", "''", ")", ".", "replace", "(", "'Module not found: Cannot find file:'", ",", "'Cannot find file:'", ")", "]", "}", "message", "=", "lines", ".", "join", "(", "'\\n'", ")", "// Internal stacks are generally useless so we strip them... with the", "// exception of stacks containing `webpack:` because they're normally", "// from user code generated by Webpack. For more information see", "// https://github.com/facebook/create-react-app/pull/1050", "message", "=", "message", ".", "replace", "(", "/", "^\\s*at\\s((?!webpack:).)*:\\d+:\\d+[\\s)]*(\\n|$)", "/", "gm", ",", "''", ")", "// at ... ...:x:y", "message", "=", "message", ".", "replace", "(", "/", "^\\s*at\\s<anonymous>(\\n|$)", "/", "gm", ",", "''", ")", "// at <anonymous>", "lines", "=", "message", ".", "split", "(", "'\\n'", ")", "// Remove duplicated newlines", "lines", "=", "lines", ".", "filter", "(", "(", "line", ",", "index", ",", "arr", ")", "=>", "index", "===", "0", "||", "line", ".", "trim", "(", ")", "!==", "''", "||", "line", ".", "trim", "(", ")", "!==", "arr", "[", "index", "-", "1", "]", ".", "trim", "(", ")", ")", "// Reassemble the message", "message", "=", "lines", ".", "join", "(", "'\\n'", ")", "return", "message", ".", "trim", "(", ")", "}"], "docstring": "Cleans up webpack error messages. eslint-disable-next-line no-unused-vars", "docstring_tokens": ["Cleans", "up", "webpack", "error", "messages", ".", "eslint", "-", "disable", "-", "next", "-", "line", "no", "-", "unused", "-", "vars"], "sha": "3641f79a0f68d1093cc238b50b8d47eec1c25cfd", "url": "https://github.com/zeit/next.js/blob/3641f79a0f68d1093cc238b50b8d47eec1c25cfd/packages/next/client/dev-error-overlay/format-webpack-messages.js#L37-L119"}, "target": "Cleans up webpack error messages . eslint - disable - next - line no - unused - vars", "arguments": {"gen_args_0": {"arg_0": "function formatMessage ( message , isError ) { let lines = message . split ( '\\n' ) // Strip Webpack-added headers off errors/warnings // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js lines = lines . filter ( line => ! / Module [A-z ]+\\(from / . test ( line ) ) // Transform parsing error into syntax error // TODO: move this to our ESLint formatter? lines = lines . map ( line => { const parsingError = / Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$ / . exec ( line ) if ( ! parsingError ) { return line } const [ , errorLine , errorColumn , errorMessage ] = parsingError return ` ${ friendlySyntaxErrorLabel } ${ errorMessage } ${ errorLine } ${ errorColumn } ` } ) message = lines . join ( '\\n' ) // Smoosh syntax errors (commonly found in CSS) message = message . replace ( / SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n / g , ` ${ friendlySyntaxErrorLabel } \\n ` ) // Remove columns from ESLint formatter output (we added these for more // accurate syntax errors) message = message . replace ( / Line (\\d+):\\d+: / g , 'Line $1:' ) // Clean up export errors message = message . replace ( / ^.*export '(.+?)' was not found in '(.+?)'.*$ / gm , ` ` ) message = message . replace ( / ^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$ / gm , ` ` ) message = message . replace ( / ^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$ / gm , ` ` ) lines = message . split ( '\\n' ) // Remove leading newline if ( lines . length > 2 && lines [ 1 ] . trim ( ) === '' ) { lines . splice ( 1 , 1 ) } // Clean up file name lines [ 0 ] = lines [ 0 ] . replace ( / ^(.*) \\d+:\\d+-\\d+$ / , '$1' ) // Cleans up verbose \"module not found\" messages for files and packages. if ( lines [ 1 ] && lines [ 1 ] . indexOf ( 'Module not found: ' ) === 0 ) { lines = [ lines [ 0 ] , lines [ 1 ] . replace ( 'Error: ' , '' ) . replace ( 'Module not found: Cannot find file:' , 'Cannot find file:' ) ] } message = lines . join ( '\\n' ) // Internal stacks are generally useless so we strip them... with the // exception of stacks containing `webpack:` because they're normally // from user code generated by Webpack. For more information see // https://github.com/facebook/create-react-app/pull/1050 message = message . replace ( / ^\\s*at\\s((?!webpack:).)*:\\d+:\\d+[\\s)]*(\\n|$) / gm , '' ) // at ... ...:x:y message = message . replace ( / ^\\s*at\\s<anonymous>(\\n|$) / gm , '' ) // at <anonymous> lines = message . split ( '\\n' ) // Remove duplicated newlines lines = lines . filter ( ( line , index , arr ) => index === 0 || line . trim ( ) !== '' || line . trim ( ) !== arr [ index - 1 ] . trim ( ) ) // Reassemble the message message = lines . join ( '\\n' ) return message . trim ( ) }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function friendlySyntaxErrorLabel () { return 'Syntax Error:' }"]], "filtered_resps": ["function friendlySyntaxErrorLabel () { return 'Syntax Error:' }"], "doc_hash": "2159aa5249fca29a17b1191d662cd4066639935adc035955fb429aa8dd6d8997", "prompt_hash": "9df6978c0f4c0b2d8c705153e8ce810b54a12647849c8e0af860a33180d92039", "target_hash": "5880438bfb98a0615c9e703dcb5f13d778921ba37709c092aa23430a2259dbf5", "smoothed_bleu_4": 5.618463950368426}
{"doc_id": 11, "doc": {"id": 11, "repo": "everitoken/evtjs", "path": "lib/format.js", "func_name": "UDecimalPad", "original_string": "function UDecimalPad(num, precision) {\n    var value = UDecimalString(num);\n    assert.equal(\"number\", typeof precision === 'undefined' ? 'undefined' : (0, _typeof3.default)(precision), \"precision\");\n\n    var part = value.split(\".\");\n\n    if (precision === 0 && part.length === 1) {\n        return part[0];\n    }\n\n    if (part.length === 1) {\n        return part[0] + '.' + \"0\".repeat(precision);\n    } else {\n        var pad = precision - part[1].length;\n        assert(pad >= 0, 'decimal \\'' + value + '\\' exceeds precision ' + precision);\n        return part[0] + '.' + part[1] + \"0\".repeat(pad);\n    }\n}", "language": "javascript", "code": "function UDecimalPad(num, precision) {\n    var value = UDecimalString(num);\n    assert.equal(\"number\", typeof precision === 'undefined' ? 'undefined' : (0, _typeof3.default)(precision), \"precision\");\n\n    var part = value.split(\".\");\n\n    if (precision === 0 && part.length === 1) {\n        return part[0];\n    }\n\n    if (part.length === 1) {\n        return part[0] + '.' + \"0\".repeat(precision);\n    } else {\n        var pad = precision - part[1].length;\n        assert(pad >= 0, 'decimal \\'' + value + '\\' exceeds precision ' + precision);\n        return part[0] + '.' + part[1] + \"0\".repeat(pad);\n    }\n}", "code_tokens": ["function", "UDecimalPad", "(", "num", ",", "precision", ")", "{", "var", "value", "=", "UDecimalString", "(", "num", ")", ";", "assert", ".", "equal", "(", "\"number\"", ",", "typeof", "precision", "===", "'undefined'", "?", "'undefined'", ":", "(", "0", ",", "_typeof3", ".", "default", ")", "(", "precision", ")", ",", "\"precision\"", ")", ";", "var", "part", "=", "value", ".", "split", "(", "\".\"", ")", ";", "if", "(", "precision", "===", "0", "&&", "part", ".", "length", "===", "1", ")", "{", "return", "part", "[", "0", "]", ";", "}", "if", "(", "part", ".", "length", "===", "1", ")", "{", "return", "part", "[", "0", "]", "+", "'.'", "+", "\"0\"", ".", "repeat", "(", "precision", ")", ";", "}", "else", "{", "var", "pad", "=", "precision", "-", "part", "[", "1", "]", ".", "length", ";", "assert", "(", "pad", ">=", "0", ",", "'decimal \\''", "+", "value", "+", "'\\' exceeds precision '", "+", "precision", ")", ";", "return", "part", "[", "0", "]", "+", "'.'", "+", "part", "[", "1", "]", "+", "\"0\"", ".", "repeat", "(", "pad", ")", ";", "}", "}"], "docstring": "Ensure a fixed number of decimal places.  Safe for large numbers.\n\n@see ./format.test.js\n\n@example UDecimalPad(10.2, 3) === '10.200'\n\n@arg {number|string|object.toString} value\n@arg {number} precision - number of decimal places\n@return {string} decimal part is added and zero padded to match precision", "docstring_tokens": ["Ensure", "a", "fixed", "number", "of", "decimal", "places", ".", "Safe", "for", "large", "numbers", "."], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/lib/format.js#L373-L390"}, "target": "Ensure a fixed number of decimal places . Safe for large numbers .", "arguments": {"gen_args_0": {"arg_0": "function UDecimalPad ( num , precision ) { var value = UDecimalString ( num ) ; assert . equal ( \"number\" , typeof precision === 'undefined' ? 'undefined' : ( 0 , _typeof3 . default ) ( precision ) , \"precision\" ) ; var part = value . split ( \".\" ) ; if ( precision === 0 && part . length === 1 ) { return part [ 0 ] ; } if ( part . length === 1 ) { return part [ 0 ] + '.' + \"0\" . repeat ( precision ) ; } else { var pad = precision - part [ 1 ] . length ; assert ( pad >= 0 , 'decimal \\'' + value + '\\' exceeds precision ' + precision ) ; return part [ 0 ] + '.' + part [ 1 ] + \"0\" . repeat ( pad ) ; } }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function UDecimalString ( num ) { var value = num . toString"]], "filtered_resps": ["function UDecimalString ( num ) { var value = num . toString"], "doc_hash": "b5a5a4a9e8c6da070449fbb6b8a92b7e328ae33b599e4856f6d9801286f7b500", "prompt_hash": "3723f54e13ec714cda3b3cd78418fd191cf98d20796ee2e909c7c6eec8df6b62", "target_hash": "cf1b77d2a3e240a9cae25ab349e7ac462466c950062883e4267110487a314a21", "smoothed_bleu_4": 8.253799936958494}
{"doc_id": 12, "doc": {"id": 12, "repo": "everitoken/evtjs", "path": "src/evtLink.js", "func_name": "parseSegment", "original_string": "function parseSegment(buffer, offset) {\n    let typeKey = buffer[offset];\n\n    if (typeKey <= 20) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: No value for uint8\");\n        return { typeKey: typeKey, value: buffer[offset + 1], bufferLength: 2 };\n    }\n    if (typeKey <= 40) {\n        if (buffer[offset + 2] == undefined) throw new Error(\"ParseError: Incomplete value for uint16\");\n        return { typeKey: typeKey, value: buffer.readUInt16BE(offset + 1), bufferLength: 3 };\n    }\n    else if (typeKey <= 90) {\n        if (buffer[offset + 4] == undefined) throw new Error(\"ParseError: Incomplete value for uint32\");\n        return { typeKey: typeKey, value: buffer.readUInt32BE(offset + 1), bufferLength: 5 };\n    }\n    else if (typeKey <= 155) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for string\");\n        let len = buffer.readUInt8(offset + 1);\n        if (buffer[offset + 1 + len] == undefined) throw new Error(\"ParseError: Incomplete value for string\");\n        let value = buffer.toString(\"utf8\", offset + 2, offset + 2 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\n    }\n    else if (typeKey <= 165) {\n        if (buffer[offset + 16] == undefined) throw new Error(\"ParseError: Incomplete value for uuid\");\n        let len = 16;\n        let value = new Buffer(len);\n        buffer.copy(value, 0, offset + 1, offset + 1 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 1 + len };\n    }\n    else if (typeKey <= 180) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for byte string\");\n        let len = buffer.readUInt8(offset + 1);\n        if (buffer[offset + len + 1] == undefined) throw new Error(\"ParseError: Incomplete value for byte string\");\n        let value = new Buffer(len);\n        buffer.copy(value, 0, offset + 2, offset + 2 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\n    }\n    else {\n        throw new Error(\"typeKey not supported\");\n    }\n}", "language": "javascript", "code": "function parseSegment(buffer, offset) {\n    let typeKey = buffer[offset];\n\n    if (typeKey <= 20) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: No value for uint8\");\n        return { typeKey: typeKey, value: buffer[offset + 1], bufferLength: 2 };\n    }\n    if (typeKey <= 40) {\n        if (buffer[offset + 2] == undefined) throw new Error(\"ParseError: Incomplete value for uint16\");\n        return { typeKey: typeKey, value: buffer.readUInt16BE(offset + 1), bufferLength: 3 };\n    }\n    else if (typeKey <= 90) {\n        if (buffer[offset + 4] == undefined) throw new Error(\"ParseError: Incomplete value for uint32\");\n        return { typeKey: typeKey, value: buffer.readUInt32BE(offset + 1), bufferLength: 5 };\n    }\n    else if (typeKey <= 155) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for string\");\n        let len = buffer.readUInt8(offset + 1);\n        if (buffer[offset + 1 + len] == undefined) throw new Error(\"ParseError: Incomplete value for string\");\n        let value = buffer.toString(\"utf8\", offset + 2, offset + 2 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\n    }\n    else if (typeKey <= 165) {\n        if (buffer[offset + 16] == undefined) throw new Error(\"ParseError: Incomplete value for uuid\");\n        let len = 16;\n        let value = new Buffer(len);\n        buffer.copy(value, 0, offset + 1, offset + 1 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 1 + len };\n    }\n    else if (typeKey <= 180) {\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for byte string\");\n        let len = buffer.readUInt8(offset + 1);\n        if (buffer[offset + len + 1] == undefined) throw new Error(\"ParseError: Incomplete value for byte string\");\n        let value = new Buffer(len);\n        buffer.copy(value, 0, offset + 2, offset + 2 + len);\n\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\n    }\n    else {\n        throw new Error(\"typeKey not supported\");\n    }\n}", "code_tokens": ["function", "parseSegment", "(", "buffer", ",", "offset", ")", "{", "let", "typeKey", "=", "buffer", "[", "offset", "]", ";", "if", "(", "typeKey", "<=", "20", ")", "{", "if", "(", "buffer", "[", "offset", "+", "1", "]", "==", "undefined", ")", "throw", "new", "Error", "(", "\"ParseError: No value for uint8\"", ")", ";", "return", "{", "typeKey", ":", "typeKey", ",", "value", ":", "buffer", "[", "offset", "+", "1", "]", ",", "bufferLength", ":", "2", "}", ";", "}", "if", "(", "typeKey", "<=", "40", ")", "{", "if", "(", "buffer", "[", "offset", "+", "2", "]", "==", "undefined", ")", "throw", "new", "Error", "(", "\"ParseError: Incomplete value for uint16\"", ")", ";", "return", "{", "typeKey", ":", "typeKey", ",", "value", ":", "buffer", ".", "readUInt16BE", "(", "offset", "+", "1", ")", ",", "bufferLength", ":", "3", "}", ";", "}", "else", "if", "(", "typeKey", "<=", "90", ")", "{", "if", "(", "buffer", "[", "offset", "+", "4", "]", "==", "undefined", ")", "throw", "new", "Error", "(", "\"ParseError: Incomplete value for uint32\"", ")", ";", "return", "{", "typeKey", ":", "typeKey", ",", "value", ":", "buffer", ".", "readUInt32BE", "(", "offset", "+", "1", ")", ",", "bufferLength", ":", "5", "}", ";", "}", "else", "if", "(", "typeKey", "<=", "155", ")", "{", "if", "(", "buffer", "[", "offset", "+", "1", "]", "==", "undefined", ")", "throw", "new", "Error", "(", "\"ParseError: Incomplete length value for string\"", ")", ";", "let", "len", "=", "buffer", ".", "readUInt8", "(", "offset", "+", "1", ")", ";", "if", "(", "buffer", "[", "offset", "+", "1", "+", "len", "]", "==", "undefined", ")", "throw", "new", "Error", "(", "\"ParseError: Incomplete value for string\"", ")", ";", "let", "value", "=", "buffer", ".", "toString", "(", "\"utf8\"", ",", "offset", "+", "2", ",", "offset", "+", "2", "+", "len", ")", ";", "return", "{", "typeKey", ":", "typeKey", ",", "value", ":", "value", ",", "bufferLength", ":", "2", "+", "len", "}", ";", "}", "else", "if", "(", "typeKey", "<=", "165", ")", "{", "if", "(", "buffer", "[", "offset", "+", "16", "]", "==", "undefined", ")", "throw", "new", "Error", "(", "\"ParseError: Incomplete value for uuid\"", ")", ";", "let", "len", "=", "16", ";", "let", "value", "=", "new", "Buffer", "(", "len", ")", ";", "buffer", ".", "copy", "(", "value", ",", "0", ",", "offset", "+", "1", ",", "offset", "+", "1", "+", "len", ")", ";", "return", "{", "typeKey", ":", "typeKey", ",", "value", ":", "value", ",", "bufferLength", ":", "1", "+", "len", "}", ";", "}", "else", "if", "(", "typeKey", "<=", "180", ")", "{", "if", "(", "buffer", "[", "offset", "+", "1", "]", "==", "undefined", ")", "throw", "new", "Error", "(", "\"ParseError: Incomplete length value for byte string\"", ")", ";", "let", "len", "=", "buffer", ".", "readUInt8", "(", "offset", "+", "1", ")", ";", "if", "(", "buffer", "[", "offset", "+", "len", "+", "1", "]", "==", "undefined", ")", "throw", "new", "Error", "(", "\"ParseError: Incomplete value for byte string\"", ")", ";", "let", "value", "=", "new", "Buffer", "(", "len", ")", ";", "buffer", ".", "copy", "(", "value", ",", "0", ",", "offset", "+", "2", ",", "offset", "+", "2", "+", "len", ")", ";", "return", "{", "typeKey", ":", "typeKey", ",", "value", ":", "value", ",", "bufferLength", ":", "2", "+", "len", "}", ";", "}", "else", "{", "throw", "new", "Error", "(", "\"typeKey not supported\"", ")", ";", "}", "}"], "docstring": "Parse a segment and convert it into json.\n@param {Buffer} buffer\n@param {number} offset", "docstring_tokens": ["Parse", "a", "segment", "and", "convert", "it", "into", "json", "."], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/evtLink.js#L138-L181"}, "target": "Parse a segment and convert it into json .", "arguments": {"gen_args_0": {"arg_0": "function parseSegment ( buffer , offset ) { let typeKey = buffer [ offset ] ; if ( typeKey <= 20 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( \"ParseError: No value for uint8\" ) ; return { typeKey : typeKey , value : buffer [ offset + 1 ] , bufferLength : 2 } ; } if ( typeKey <= 40 ) { if ( buffer [ offset + 2 ] == undefined ) throw new Error ( \"ParseError: Incomplete value for uint16\" ) ; return { typeKey : typeKey , value : buffer . readUInt16BE ( offset + 1 ) , bufferLength : 3 } ; } else if ( typeKey <= 90 ) { if ( buffer [ offset + 4 ] == undefined ) throw new Error ( \"ParseError: Incomplete value for uint32\" ) ; return { typeKey : typeKey , value : buffer . readUInt32BE ( offset + 1 ) , bufferLength : 5 } ; } else if ( typeKey <= 155 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( \"ParseError: Incomplete length value for string\" ) ; let len = buffer . readUInt8 ( offset + 1 ) ; if ( buffer [ offset + 1 + len ] == undefined ) throw new Error ( \"ParseError: Incomplete value for string\" ) ; let value = buffer . toString ( \"utf8\" , offset + 2 , offset + 2 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 2 + len } ; } else if ( typeKey <= 165 ) { if ( buffer [ offset + 16 ] == undefined ) throw new Error ( \"ParseError: Incomplete value for uuid\" ) ; let len = 16 ; let value = new Buffer ( len ) ; buffer . copy ( value , 0 , offset + 1 , offset + 1 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 1 + len } ; } else if ( typeKey <= 180 ) { if ( buffer [ offset + 1 ] == undefined ) throw new Error ( \"ParseError: Incomplete length value for byte string\" ) ; let len = buffer . readUInt8 ( offset + 1 ) ; if ( buffer [ offset + len + 1 ] == undefined ) throw new Error ( \"ParseError: Incomplete value for byte string\" ) ; let value = new Buffer ( len ) ; buffer . copy ( value , 0 , offset + 2 , offset + 2 + len ) ; return { typeKey : typeKey , value : value , bufferLength : 2 + len } ; } else { throw new Error ( \"typeKey not supported\" ) ; } }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function parseSegmentList ( buffer , offset ) { let segments = []"]], "filtered_resps": ["function parseSegmentList ( buffer , offset ) { let segments = []"], "doc_hash": "c4dc659edf523cc9acaca6640ca8fda7cb803507be9540d737a727a1ee71ec4c", "prompt_hash": "a33094f4be8b0de5d5a2be71a48573d1eb7402e9940f68e2d8458a6242475260", "target_hash": "9a271d463c9e8d5f42fd4011f0d62b7fda76e296dcfda14a9531176f91d89718", "smoothed_bleu_4": 9.993576674761412e-77}
{"doc_id": 13, "doc": {"id": 13, "repo": "everitoken/evtjs", "path": "src/evtLink.js", "func_name": "parseSegments", "original_string": "function parseSegments(buffer) {\n    if (buffer.length == 0) throw new Error(\"bad segments stream\");\n\n    let pointer = 0;\n    let segments = [ ];\n\n    while (pointer < buffer.length) {\n        let seg = parseSegment(buffer, pointer);\n        segments.push(seg);\n        pointer += seg.bufferLength;\n        delete seg.bufferLength;\n    }\n\n    if (pointer != buffer.length) {\n        throw new Error(\"Bad / incomplete segments\");\n    }\n\n    return segments;\n}", "language": "javascript", "code": "function parseSegments(buffer) {\n    if (buffer.length == 0) throw new Error(\"bad segments stream\");\n\n    let pointer = 0;\n    let segments = [ ];\n\n    while (pointer < buffer.length) {\n        let seg = parseSegment(buffer, pointer);\n        segments.push(seg);\n        pointer += seg.bufferLength;\n        delete seg.bufferLength;\n    }\n\n    if (pointer != buffer.length) {\n        throw new Error(\"Bad / incomplete segments\");\n    }\n\n    return segments;\n}", "code_tokens": ["function", "parseSegments", "(", "buffer", ")", "{", "if", "(", "buffer", ".", "length", "==", "0", ")", "throw", "new", "Error", "(", "\"bad segments stream\"", ")", ";", "let", "pointer", "=", "0", ";", "let", "segments", "=", "[", "]", ";", "while", "(", "pointer", "<", "buffer", ".", "length", ")", "{", "let", "seg", "=", "parseSegment", "(", "buffer", ",", "pointer", ")", ";", "segments", ".", "push", "(", "seg", ")", ";", "pointer", "+=", "seg", ".", "bufferLength", ";", "delete", "seg", ".", "bufferLength", ";", "}", "if", "(", "pointer", "!=", "buffer", ".", "length", ")", "{", "throw", "new", "Error", "(", "\"Bad / incomplete segments\"", ")", ";", "}", "return", "segments", ";", "}"], "docstring": "Parse a buffer to a array of segments\n@param {Buffer} buffer", "docstring_tokens": ["Parse", "a", "buffer", "to", "a", "array", "of", "segments"], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/evtLink.js#L187-L205"}, "target": "Parse a buffer to a array of segments", "arguments": {"gen_args_0": {"arg_0": "function parseSegments ( buffer ) { if ( buffer . length == 0 ) throw new Error ( \"bad segments stream\" ) ; let pointer = 0 ; let segments = [ ] ; while ( pointer < buffer . length ) { let seg = parseSegment ( buffer , pointer ) ; segments . push ( seg ) ; pointer += seg . bufferLength ; delete seg . bufferLength ; } if ( pointer != buffer . length ) { throw new Error ( \"Bad / incomplete segments\" ) ; } return segments ; }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function parseSegment ( buffer , pointer ) { let segment = { } ; segment"]], "filtered_resps": ["function parseSegment ( buffer , pointer ) { let segment = { } ; segment"], "doc_hash": "841e90d48d2a0aceb6d2a7cb53af2bd387cccf5a9a3ba36c1b2954c95dc398b4", "prompt_hash": "e7501f25d701f469fedcf23f785989fa29ea80aab022eb156bf5bde928dc1ce3", "target_hash": "36f0880bbcc23e5cc8149408b9110f13833c3cfadc5a331eaf4485baa3dac223", "smoothed_bleu_4": 7.029695662739612}
{"doc_id": 14, "doc": {"id": 14, "repo": "everitoken/evtjs", "path": "src/evtLink.js", "func_name": "parseQRCode", "original_string": "function parseQRCode(text, options) {\n    if (text.length < 3 || text.length > 2000) throw new Error(\"Invalid length of EvtLink\");\n\n    let textSplited = text.split(\"_\");\n    if (textSplited.length > 2) return null;\n\n    let rawText;\n\n    if (textSplited[0].startsWith(qrPrefix)) {\n        rawText = textSplited[0].substr(qrPrefix.length);\n    }\n    else {\n        rawText = textSplited[0];\n    }\n    \n    // decode segments base42\n    let segmentsBytes = EvtLink.dec2b(rawText);\n    if (segmentsBytes.length < 2) throw new Error(\"no flag in segment\");\n    let flag = segmentsBytes.readInt16BE(0);\n    \n    if ((flag & 1) == 0) { // check version of EvtLink\n        throw new Error(\"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\");\n    }\n    let segmentsBytesRaw = new Buffer(segmentsBytes.length - 2);\n    segmentsBytes.copy(segmentsBytesRaw, 0, 2, segmentsBytes.length);\n\n    let publicKeys = [ ];\n    let signatures = [ ];\n\n    if (textSplited[1]) {\n        let buf = EvtLink.dec2b(textSplited[1]);\n        let i = 0;\n\n        if (buf.length % 65 !== 0) {\n            throw new Error(\"length of signature is invalid\");\n        }\n\n        while (i * 65 < buf.length) {\n            let current = new Buffer(65);\n            buf.copy(current, 0, i * 65, i * 65 + 65);\n            let signature = ecc.Signature.fromBuffer(current);\n            signatures.push(signature.toString());\n\n            if (!options || options.recoverPublicKeys) {\n                publicKeys.push(signature.recover(segmentsBytes).toString());\n            }\n\n            ++i;\n        }\n    }\n\n    return { flag, segments: parseSegments(segmentsBytesRaw), publicKeys, signatures };\n}", "language": "javascript", "code": "function parseQRCode(text, options) {\n    if (text.length < 3 || text.length > 2000) throw new Error(\"Invalid length of EvtLink\");\n\n    let textSplited = text.split(\"_\");\n    if (textSplited.length > 2) return null;\n\n    let rawText;\n\n    if (textSplited[0].startsWith(qrPrefix)) {\n        rawText = textSplited[0].substr(qrPrefix.length);\n    }\n    else {\n        rawText = textSplited[0];\n    }\n    \n    // decode segments base42\n    let segmentsBytes = EvtLink.dec2b(rawText);\n    if (segmentsBytes.length < 2) throw new Error(\"no flag in segment\");\n    let flag = segmentsBytes.readInt16BE(0);\n    \n    if ((flag & 1) == 0) { // check version of EvtLink\n        throw new Error(\"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\");\n    }\n    let segmentsBytesRaw = new Buffer(segmentsBytes.length - 2);\n    segmentsBytes.copy(segmentsBytesRaw, 0, 2, segmentsBytes.length);\n\n    let publicKeys = [ ];\n    let signatures = [ ];\n\n    if (textSplited[1]) {\n        let buf = EvtLink.dec2b(textSplited[1]);\n        let i = 0;\n\n        if (buf.length % 65 !== 0) {\n            throw new Error(\"length of signature is invalid\");\n        }\n\n        while (i * 65 < buf.length) {\n            let current = new Buffer(65);\n            buf.copy(current, 0, i * 65, i * 65 + 65);\n            let signature = ecc.Signature.fromBuffer(current);\n            signatures.push(signature.toString());\n\n            if (!options || options.recoverPublicKeys) {\n                publicKeys.push(signature.recover(segmentsBytes).toString());\n            }\n\n            ++i;\n        }\n    }\n\n    return { flag, segments: parseSegments(segmentsBytesRaw), publicKeys, signatures };\n}", "code_tokens": ["function", "parseQRCode", "(", "text", ",", "options", ")", "{", "if", "(", "text", ".", "length", "<", "3", "||", "text", ".", "length", ">", "2000", ")", "throw", "new", "Error", "(", "\"Invalid length of EvtLink\"", ")", ";", "let", "textSplited", "=", "text", ".", "split", "(", "\"_\"", ")", ";", "if", "(", "textSplited", ".", "length", ">", "2", ")", "return", "null", ";", "let", "rawText", ";", "if", "(", "textSplited", "[", "0", "]", ".", "startsWith", "(", "qrPrefix", ")", ")", "{", "rawText", "=", "textSplited", "[", "0", "]", ".", "substr", "(", "qrPrefix", ".", "length", ")", ";", "}", "else", "{", "rawText", "=", "textSplited", "[", "0", "]", ";", "}", "// decode segments base42", "let", "segmentsBytes", "=", "EvtLink", ".", "dec2b", "(", "rawText", ")", ";", "if", "(", "segmentsBytes", ".", "length", "<", "2", ")", "throw", "new", "Error", "(", "\"no flag in segment\"", ")", ";", "let", "flag", "=", "segmentsBytes", ".", "readInt16BE", "(", "0", ")", ";", "if", "(", "(", "flag", "&", "1", ")", "==", "0", ")", "{", "// check version of EvtLink", "throw", "new", "Error", "(", "\"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\"", ")", ";", "}", "let", "segmentsBytesRaw", "=", "new", "Buffer", "(", "segmentsBytes", ".", "length", "-", "2", ")", ";", "segmentsBytes", ".", "copy", "(", "segmentsBytesRaw", ",", "0", ",", "2", ",", "segmentsBytes", ".", "length", ")", ";", "let", "publicKeys", "=", "[", "]", ";", "let", "signatures", "=", "[", "]", ";", "if", "(", "textSplited", "[", "1", "]", ")", "{", "let", "buf", "=", "EvtLink", ".", "dec2b", "(", "textSplited", "[", "1", "]", ")", ";", "let", "i", "=", "0", ";", "if", "(", "buf", ".", "length", "%", "65", "!==", "0", ")", "{", "throw", "new", "Error", "(", "\"length of signature is invalid\"", ")", ";", "}", "while", "(", "i", "*", "65", "<", "buf", ".", "length", ")", "{", "let", "current", "=", "new", "Buffer", "(", "65", ")", ";", "buf", ".", "copy", "(", "current", ",", "0", ",", "i", "*", "65", ",", "i", "*", "65", "+", "65", ")", ";", "let", "signature", "=", "ecc", ".", "Signature", ".", "fromBuffer", "(", "current", ")", ";", "signatures", ".", "push", "(", "signature", ".", "toString", "(", ")", ")", ";", "if", "(", "!", "options", "||", "options", ".", "recoverPublicKeys", ")", "{", "publicKeys", ".", "push", "(", "signature", ".", "recover", "(", "segmentsBytes", ")", ".", "toString", "(", ")", ")", ";", "}", "++", "i", ";", "}", "}", "return", "{", "flag", ",", "segments", ":", "parseSegments", "(", "segmentsBytesRaw", ")", ",", "publicKeys", ",", "signatures", "}", ";", "}"], "docstring": "Parse a everiToken's QRCode Text\n@param {string} text", "docstring_tokens": ["Parse", "a", "everiToken", "s", "QRCode", "Text"], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/evtLink.js#L211-L263"}, "target": "Parse a everiToken s QRCode Text", "arguments": {"gen_args_0": {"arg_0": "function parseQRCode ( text , options ) { if ( text . length < 3 || text . length > 2000 ) throw new Error ( \"Invalid length of EvtLink\" ) ; let textSplited = text . split ( \"_\" ) ; if ( textSplited . length > 2 ) return null ; let rawText ; if ( textSplited [ 0 ] . startsWith ( qrPrefix ) ) { rawText = textSplited [ 0 ] . substr ( qrPrefix . length ) ; } else { rawText = textSplited [ 0 ] ; } // decode segments base42 let segmentsBytes = EvtLink . dec2b ( rawText ) ; if ( segmentsBytes . length < 2 ) throw new Error ( \"no flag in segment\" ) ; let flag = segmentsBytes . readInt16BE ( 0 ) ; if ( ( flag & 1 ) == 0 ) { // check version of EvtLink throw new Error ( \"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\" ) ; } let segmentsBytesRaw = new Buffer ( segmentsBytes . length - 2 ) ; segmentsBytes . copy ( segmentsBytesRaw , 0 , 2 , segmentsBytes . length ) ; let publicKeys = [ ] ; let signatures = [ ] ; if ( textSplited [ 1 ] ) { let buf = EvtLink . dec2b ( textSplited [ 1 ] ) ; let i = 0 ; if ( buf . length % 65 !== 0 ) { throw new Error ( \"length of signature is invalid\" ) ; } while ( i * 65 < buf . length ) { let current = new Buffer ( 65 ) ; buf . copy ( current , 0 , i * 65 , i * 65 + 65 ) ; let signature = ecc . Signature . fromBuffer ( current ) ; signatures . push ( signature . toString ( ) ) ; if ( ! options || options . recoverPublicKeys ) { publicKeys . push ( signature . recover ( segmentsBytes ) . toString ( ) ) ; } ++ i ; } } return { flag , segments : parseSegments ( segmentsBytesRaw ) , publicKeys , signatures } ; }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function parseSegments ( segments ) { let segmentsParsed = [ ] ;"]], "filtered_resps": ["function parseSegments ( segments ) { let segmentsParsed = [ ] ;"], "doc_hash": "939118b825f56c0c064f831ac6201aa6f205a88c2fd06c195c21a51e339bdf0a", "prompt_hash": "8137a8dcd9b7f686abb1589ff443ffffaad8fd0dfd172262843050f50b89ca55", "target_hash": "9ef2d7276e4e026c4334e709327e82055d77c0f4bf1d2f545a6e9c94ee3ab498", "smoothed_bleu_4": 1.0886726524416985e-76}
{"doc_id": 15, "doc": {"id": 15, "repo": "everitoken/evtjs", "path": "src/evtLink.js", "func_name": "__calcKeyProvider", "original_string": "async function __calcKeyProvider(keyProvider) {\n    if (!keyProvider) { return []; }\n\n    // if keyProvider is function\n    if (keyProvider.apply && keyProvider.call) {\n        keyProvider = keyProvider();\n    }\n\n    // resolve for Promise\n    keyProvider = await Promise.resolve(keyProvider);\n\n    if (!Array.isArray(keyProvider)) {\n        keyProvider = [ keyProvider ];\n    }\n\n    for (let key of keyProvider) {\n        if (!EvtKey.isValidPrivateKey(key)) {\n            throw new Error(\"Invalid private key\");\n        }\n    }\n\n    return keyProvider;\n}", "language": "javascript", "code": "async function __calcKeyProvider(keyProvider) {\n    if (!keyProvider) { return []; }\n\n    // if keyProvider is function\n    if (keyProvider.apply && keyProvider.call) {\n        keyProvider = keyProvider();\n    }\n\n    // resolve for Promise\n    keyProvider = await Promise.resolve(keyProvider);\n\n    if (!Array.isArray(keyProvider)) {\n        keyProvider = [ keyProvider ];\n    }\n\n    for (let key of keyProvider) {\n        if (!EvtKey.isValidPrivateKey(key)) {\n            throw new Error(\"Invalid private key\");\n        }\n    }\n\n    return keyProvider;\n}", "code_tokens": ["async", "function", "__calcKeyProvider", "(", "keyProvider", ")", "{", "if", "(", "!", "keyProvider", ")", "{", "return", "[", "]", ";", "}", "// if keyProvider is function", "if", "(", "keyProvider", ".", "apply", "&&", "keyProvider", ".", "call", ")", "{", "keyProvider", "=", "keyProvider", "(", ")", ";", "}", "// resolve for Promise", "keyProvider", "=", "await", "Promise", ".", "resolve", "(", "keyProvider", ")", ";", "if", "(", "!", "Array", ".", "isArray", "(", "keyProvider", ")", ")", "{", "keyProvider", "=", "[", "keyProvider", "]", ";", "}", "for", "(", "let", "key", "of", "keyProvider", ")", "{", "if", "(", "!", "EvtKey", ".", "isValidPrivateKey", "(", "key", ")", ")", "{", "throw", "new", "Error", "(", "\"Invalid private key\"", ")", ";", "}", "}", "return", "keyProvider", ";", "}"], "docstring": "Calculate the value of keyProvider\n@param {string | string[] | function} keyProvider\n@returns {string[]}", "docstring_tokens": ["Calculate", "the", "value", "of", "keyProvider"], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/evtLink.js#L270-L292"}, "target": "Calculate the value of keyProvider", "arguments": {"gen_args_0": {"arg_0": "async function __calcKeyProvider ( keyProvider ) { if ( ! keyProvider ) { return [ ] ; } // if keyProvider is function if ( keyProvider . apply && keyProvider . call ) { keyProvider = keyProvider ( ) ; } // resolve for Promise keyProvider = await Promise . resolve ( keyProvider ) ; if ( ! Array . isArray ( keyProvider ) ) { keyProvider = [ keyProvider ] ; } for ( let key of keyProvider ) { if ( ! EvtKey . isValidPrivateKey ( key ) ) { throw new Error ( \"Invalid private key\" ) ; } } return keyProvider ; }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["async function __calcPublicKey ( publicKey ) { if ( !"]], "filtered_resps": ["async function __calcPublicKey ( publicKey ) { if ( !"], "doc_hash": "41144274fb8c8ba524079c69cb8fd40b1fcd8b564a6d224d76adc6c7851f6e56", "prompt_hash": "2020d41940d2b7d6bea0d77a0d40cd8f9694e4aaa0fce756c314d3fb0a444a45", "target_hash": "74017a57c691dbdf2d28323e58cab7d0d7dc7949390f9f43113bc6b7170825cd", "smoothed_bleu_4": 1.0886726524416985e-76}
{"doc_id": 16, "doc": {"id": 16, "repo": "everitoken/evtjs", "path": "src/ecc/key_utils.js", "func_name": "random32ByteBuffer", "original_string": "function random32ByteBuffer({cpuEntropyBits = 0, safe = true} = {}) {\n    assert.equal(typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\");\n    assert.equal(typeof safe, \"boolean\", \"boolean\");\n\n    if(safe) {\n        assert(entropyCount >= 128, \"Call initialize() to add entropy (current: \" + entropyCount + \")\");\n    }\n\n    // if(entropyCount > 0) {\n    //     console.log(`Additional private key entropy: ${entropyCount} events`)\n    // }\n\n    const hash_array = [];\n    hash_array.push(randomBytes(32));\n    hash_array.push(Buffer.from(cpuEntropy(cpuEntropyBits)));\n    hash_array.push(externalEntropyArray);\n    hash_array.push(browserEntropy());\n    return hash.sha256(Buffer.concat(hash_array));\n}", "language": "javascript", "code": "function random32ByteBuffer({cpuEntropyBits = 0, safe = true} = {}) {\n    assert.equal(typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\");\n    assert.equal(typeof safe, \"boolean\", \"boolean\");\n\n    if(safe) {\n        assert(entropyCount >= 128, \"Call initialize() to add entropy (current: \" + entropyCount + \")\");\n    }\n\n    // if(entropyCount > 0) {\n    //     console.log(`Additional private key entropy: ${entropyCount} events`)\n    // }\n\n    const hash_array = [];\n    hash_array.push(randomBytes(32));\n    hash_array.push(Buffer.from(cpuEntropy(cpuEntropyBits)));\n    hash_array.push(externalEntropyArray);\n    hash_array.push(browserEntropy());\n    return hash.sha256(Buffer.concat(hash_array));\n}", "code_tokens": ["function", "random32ByteBuffer", "(", "{", "cpuEntropyBits", "=", "0", ",", "safe", "=", "true", "}", "=", "{", "}", ")", "{", "assert", ".", "equal", "(", "typeof", "cpuEntropyBits", ",", "\"number\"", ",", "\"cpuEntropyBits\"", ")", ";", "assert", ".", "equal", "(", "typeof", "safe", ",", "\"boolean\"", ",", "\"boolean\"", ")", ";", "if", "(", "safe", ")", "{", "assert", "(", "entropyCount", ">=", "128", ",", "\"Call initialize() to add entropy (current: \"", "+", "entropyCount", "+", "\")\"", ")", ";", "}", "// if(entropyCount > 0) {", "//     console.log(`Additional private key entropy: ${entropyCount} events`)", "// }", "const", "hash_array", "=", "[", "]", ";", "hash_array", ".", "push", "(", "randomBytes", "(", "32", ")", ")", ";", "hash_array", ".", "push", "(", "Buffer", ".", "from", "(", "cpuEntropy", "(", "cpuEntropyBits", ")", ")", ")", ";", "hash_array", ".", "push", "(", "externalEntropyArray", ")", ";", "hash_array", ".", "push", "(", "browserEntropy", "(", ")", ")", ";", "return", "hash", ".", "sha256", "(", "Buffer", ".", "concat", "(", "hash_array", ")", ")", ";", "}"], "docstring": "Additional forms of entropy are used.  A week random number generator can run out of entropy.  This should ensure even the worst random number implementation will be reasonably safe.\n\n@arg {number} [cpuEntropyBits = 0] generate entropy on the fly.  This is\nnot required, entropy can be added in advanced via addEntropy or initialize().\n\n@arg {boolean} [safe = true] false for testing, otherwise this will be\ntrue to ensure initialize() was called.\n\n@return a random buffer obtained from the secure random number generator.  Additional entropy is used.", "docstring_tokens": ["Additional", "forms", "of", "entropy", "are", "used", ".", "A", "week", "random", "number", "generator", "can", "run", "out", "of", "entropy", ".", "This", "should", "ensure", "even", "the", "worst", "random", "number", "implementation", "will", "be", "reasonably", "safe", "."], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/key_utils.js#L32-L50"}, "target": "Additional forms of entropy are used . A week random number generator can run out of entropy . This should ensure even the worst random number implementation will be reasonably safe .", "arguments": {"gen_args_0": {"arg_0": "function random32ByteBuffer ( { cpuEntropyBits = 0 , safe = true } = { } ) { assert . equal ( typeof cpuEntropyBits , \"number\" , \"cpuEntropyBits\" ) ; assert . equal ( typeof safe , \"boolean\" , \"boolean\" ) ; if ( safe ) { assert ( entropyCount >= 128 , \"Call initialize() to add entropy (current: \" + entropyCount + \")\" ) ; } // if(entropyCount > 0) { // console.log(`Additional private key entropy: ${entropyCount} events`) // } const hash_array = [ ] ; hash_array . push ( randomBytes ( 32 ) ) ; hash_array . push ( Buffer . from ( cpuEntropy ( cpuEntropyBits ) ) ) ; hash_array . push ( externalEntropyArray ) ; hash_array . push ( browserEntropy ( ) ) ; return hash . sha256 ( Buffer . concat ( hash_array ) ) ; }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function random32ByteBuffer ( { cpuEntropyBits ="]], "filtered_resps": ["function random32ByteBuffer ( { cpuEntropyBits ="], "doc_hash": "fdf51ba532bc33fe7c9fb314fd52176726a93cec1b1e1622428a6f3e1809f995", "prompt_hash": "c07e244247bd83e1151cc2754a15bbeb033fe06db9a8a78bbe6b36e4b18a6ef2", "target_hash": "4e7bf281bc2461d61eb83c10d6eab258b4d6208f3b41de17dfe1d8b042caab8b", "smoothed_bleu_4": 5.746576517126244e-78}
{"doc_id": 17, "doc": {"id": 17, "repo": "everitoken/evtjs", "path": "src/ecc/key_utils.js", "func_name": "addEntropy", "original_string": "function addEntropy(...ints) {\n    assert.equal(externalEntropyArray.length, 101, \"externalEntropyArray\");\n\n    entropyCount += ints.length;\n    for(const i of ints) {\n        const pos = entropyPos++ % 101;\n        const i2 = externalEntropyArray[pos] += i;\n        if(i2 > 9007199254740991)\n            externalEntropyArray[pos] = 0;\n    }\n}", "language": "javascript", "code": "function addEntropy(...ints) {\n    assert.equal(externalEntropyArray.length, 101, \"externalEntropyArray\");\n\n    entropyCount += ints.length;\n    for(const i of ints) {\n        const pos = entropyPos++ % 101;\n        const i2 = externalEntropyArray[pos] += i;\n        if(i2 > 9007199254740991)\n            externalEntropyArray[pos] = 0;\n    }\n}", "code_tokens": ["function", "addEntropy", "(", "...", "ints", ")", "{", "assert", ".", "equal", "(", "externalEntropyArray", ".", "length", ",", "101", ",", "\"externalEntropyArray\"", ")", ";", "entropyCount", "+=", "ints", ".", "length", ";", "for", "(", "const", "i", "of", "ints", ")", "{", "const", "pos", "=", "entropyPos", "++", "%", "101", ";", "const", "i2", "=", "externalEntropyArray", "[", "pos", "]", "+=", "i", ";", "if", "(", "i2", ">", "9007199254740991", ")", "externalEntropyArray", "[", "pos", "]", "=", "0", ";", "}", "}"], "docstring": "Adds entropy.  This may be called many times while the amount of data saved\nis accumulatively reduced to 101 integers.  Data is retained in RAM for the\nlife of this module.\n\n@example React <code>\ncomponentDidMount() {\nthis.refs.MyComponent.addEventListener(\"mousemove\", this.onEntropyEvent, {capture: false, passive: true})\n}\ncomponentWillUnmount() {\nthis.refs.MyComponent.removeEventListener(\"mousemove\", this.onEntropyEvent);\n}\nonEntropyEvent = (e) => {\nif(e.type === 'mousemove')\nkey_utils.addEntropy(e.pageX, e.pageY, e.screenX, e.screenY)\nelse\nconsole.log('onEntropyEvent Unknown', e.type, e)\n}\n</code>", "docstring_tokens": ["Adds", "entropy", ".", "This", "may", "be", "called", "many", "times", "while", "the", "amount", "of", "data", "saved", "is", "accumulatively", "reduced", "to", "101", "integers", ".", "Data", "is", "retained", "in", "RAM", "for", "the", "life", "of", "this", "module", "."], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/key_utils.js#L72-L82"}, "target": "Adds entropy . This may be called many times while the amount of data saved is accumulatively reduced to 101 integers . Data is retained in RAM for the life of this module .", "arguments": {"gen_args_0": {"arg_0": "function addEntropy ( ... ints ) { assert . equal ( externalEntropyArray . length , 101 , \"externalEntropyArray\" ) ; entropyCount += ints . length ; for ( const i of ints ) { const pos = entropyPos ++ % 101 ; const i2 = externalEntropyArray [ pos ] += i ; if ( i2 > 9007199254740991 ) externalEntropyArray [ pos ] = 0 ; } }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function addEntropyFromString ( str ) { assert . equal ("]], "filtered_resps": ["function addEntropyFromString ( str ) { assert . equal ("], "doc_hash": "c1eae43edccd25015fc0ac278d3ab49c2de4b0822f8d7214f40d5f4e2f03b1f2", "prompt_hash": "36229c37b373aff49607cce7f4ec2e9b48d269b7b624234a31814ea9c5d03007", "target_hash": "650739cebce402a136c81beb4b6cd34ff8e0703fc90b9e69fbbed21b85df91b7", "smoothed_bleu_4": 1.22494130421092}
{"doc_id": 18, "doc": {"id": 18, "repo": "everitoken/evtjs", "path": "src/ecc/key_utils.js", "func_name": "cpuEntropy", "original_string": "function cpuEntropy(cpuEntropyBits = 128) {\n    let collected = [];\n    let lastCount = null;\n    let lowEntropySamples = 0;\n    while(collected.length < cpuEntropyBits) {\n        const count = floatingPointCount();\n        if(lastCount != null) {\n            const delta = count - lastCount;\n            if(Math.abs(delta) < 1) {\n                lowEntropySamples++;\n                continue;\n            }\n            // how many bits of entropy were in this sample\n            const bits = Math.floor(log2(Math.abs(delta)) + 1);\n            if(bits < 4) {\n                if(bits < 2) {\n                    lowEntropySamples++;\n                }\n                continue;\n            }\n            collected.push(delta);\n        }\n        lastCount = count;\n    }\n    if(lowEntropySamples > 10) {\n        const pct = Number(lowEntropySamples / cpuEntropyBits * 100).toFixed(2);\n        // Is this algorithm getting inefficient?\n        console.warn(`WARN: ${pct}% low CPU entropy re-sampled`);\n    }\n    return collected;\n}", "language": "javascript", "code": "function cpuEntropy(cpuEntropyBits = 128) {\n    let collected = [];\n    let lastCount = null;\n    let lowEntropySamples = 0;\n    while(collected.length < cpuEntropyBits) {\n        const count = floatingPointCount();\n        if(lastCount != null) {\n            const delta = count - lastCount;\n            if(Math.abs(delta) < 1) {\n                lowEntropySamples++;\n                continue;\n            }\n            // how many bits of entropy were in this sample\n            const bits = Math.floor(log2(Math.abs(delta)) + 1);\n            if(bits < 4) {\n                if(bits < 2) {\n                    lowEntropySamples++;\n                }\n                continue;\n            }\n            collected.push(delta);\n        }\n        lastCount = count;\n    }\n    if(lowEntropySamples > 10) {\n        const pct = Number(lowEntropySamples / cpuEntropyBits * 100).toFixed(2);\n        // Is this algorithm getting inefficient?\n        console.warn(`WARN: ${pct}% low CPU entropy re-sampled`);\n    }\n    return collected;\n}", "code_tokens": ["function", "cpuEntropy", "(", "cpuEntropyBits", "=", "128", ")", "{", "let", "collected", "=", "[", "]", ";", "let", "lastCount", "=", "null", ";", "let", "lowEntropySamples", "=", "0", ";", "while", "(", "collected", ".", "length", "<", "cpuEntropyBits", ")", "{", "const", "count", "=", "floatingPointCount", "(", ")", ";", "if", "(", "lastCount", "!=", "null", ")", "{", "const", "delta", "=", "count", "-", "lastCount", ";", "if", "(", "Math", ".", "abs", "(", "delta", ")", "<", "1", ")", "{", "lowEntropySamples", "++", ";", "continue", ";", "}", "// how many bits of entropy were in this sample", "const", "bits", "=", "Math", ".", "floor", "(", "log2", "(", "Math", ".", "abs", "(", "delta", ")", ")", "+", "1", ")", ";", "if", "(", "bits", "<", "4", ")", "{", "if", "(", "bits", "<", "2", ")", "{", "lowEntropySamples", "++", ";", "}", "continue", ";", "}", "collected", ".", "push", "(", "delta", ")", ";", "}", "lastCount", "=", "count", ";", "}", "if", "(", "lowEntropySamples", ">", "10", ")", "{", "const", "pct", "=", "Number", "(", "lowEntropySamples", "/", "cpuEntropyBits", "*", "100", ")", ".", "toFixed", "(", "2", ")", ";", "// Is this algorithm getting inefficient?", "console", ".", "warn", "(", "`", "${", "pct", "}", "`", ")", ";", "}", "return", "collected", ";", "}"], "docstring": "This runs in just under 1 second and ensures a minimum of cpuEntropyBits\nbits of entropy are gathered.\n\nBased on more-entropy. @see https://github.com/keybase/more-entropy/blob/master/src/generator.iced\n\n@arg {number} [cpuEntropyBits = 128]\n@return {array} counts gathered by measuring variations in the CPU speed during floating point operations.", "docstring_tokens": ["This", "runs", "in", "just", "under", "1", "second", "and", "ensures", "a", "minimum", "of", "cpuEntropyBits", "bits", "of", "entropy", "are", "gathered", "."], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/key_utils.js#L93-L123"}, "target": "This runs in just under 1 second and ensures a minimum of cpuEntropyBits bits of entropy are gathered .", "arguments": {"gen_args_0": {"arg_0": "function cpuEntropy ( cpuEntropyBits = 128 ) { let collected = [ ] ; let lastCount = null ; let lowEntropySamples = 0 ; while ( collected . length < cpuEntropyBits ) { const count = floatingPointCount ( ) ; if ( lastCount != null ) { const delta = count - lastCount ; if ( Math . abs ( delta ) < 1 ) { lowEntropySamples ++ ; continue ; } // how many bits of entropy were in this sample const bits = Math . floor ( log2 ( Math . abs ( delta ) ) + 1 ) ; if ( bits < 4 ) { if ( bits < 2 ) { lowEntropySamples ++ ; } continue ; } collected . push ( delta ) ; } lastCount = count ; } if ( lowEntropySamples > 10 ) { const pct = Number ( lowEntropySamples / cpuEntropyBits * 100 ) . toFixed ( 2 ) ; // Is this algorithm getting inefficient? console . warn ( ` ${ pct } ` ) ; } return collected ; }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function floatingPointCount ( ) { let count = 0 ; const"]], "filtered_resps": ["function floatingPointCount ( ) { let count = 0 ; const"], "doc_hash": "65dcd268adf7ee659473b3c1bef9d02e1f02e927a4ce9cd0a205c9fe64f05fb6", "prompt_hash": "db4b3217536dc776344141a9af82445ed4e21b9548728bc16f369b35fb5a40cb", "target_hash": "32ed84cddf6745ed0d4c143938aafbe4a9086a6f820c8d4862819efb72edbf00", "smoothed_bleu_4": 6.138319409069587e-77}
{"doc_id": 19, "doc": {"id": 19, "repo": "everitoken/evtjs", "path": "src/ecc/aes.js", "func_name": "cryptoJsDecrypt", "original_string": "function cryptoJsDecrypt(message, key, iv) {\n    assert(message, \"Missing cipher text\");\n    message = toBinaryBuffer(message);\n    const decipher = crypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n    // decipher.setAutoPadding(true)\n    message = Buffer.concat([decipher.update(message), decipher.final()]);\n    return message;\n}", "language": "javascript", "code": "function cryptoJsDecrypt(message, key, iv) {\n    assert(message, \"Missing cipher text\");\n    message = toBinaryBuffer(message);\n    const decipher = crypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n    // decipher.setAutoPadding(true)\n    message = Buffer.concat([decipher.update(message), decipher.final()]);\n    return message;\n}", "code_tokens": ["function", "cryptoJsDecrypt", "(", "message", ",", "key", ",", "iv", ")", "{", "assert", "(", "message", ",", "\"Missing cipher text\"", ")", ";", "message", "=", "toBinaryBuffer", "(", "message", ")", ";", "const", "decipher", "=", "crypto", ".", "createDecipheriv", "(", "\"aes-256-cbc\"", ",", "key", ",", "iv", ")", ";", "// decipher.setAutoPadding(true)", "message", "=", "Buffer", ".", "concat", "(", "[", "decipher", ".", "update", "(", "message", ")", ",", "decipher", ".", "final", "(", ")", "]", ")", ";", "return", "message", ";", "}"], "docstring": "This method does not use a checksum, the returned data must be validated some other way.\n\n@arg {string|Buffer} message - ciphertext binary format\n@arg {string<utf8>|Buffer} key - 256bit\n@arg {string<utf8>|Buffer} iv - 128bit\n\n@return {Buffer}", "docstring_tokens": ["This", "method", "does", "not", "use", "a", "checksum", "the", "returned", "data", "must", "be", "validated", "some", "other", "way", "."], "sha": "87d5dac3ae3205e654821c03c010e4738fc4b8a1", "url": "https://github.com/everitoken/evtjs/blob/87d5dac3ae3205e654821c03c010e4738fc4b8a1/src/ecc/aes.js#L122-L129"}, "target": "This method does not use a checksum the returned data must be validated some other way .", "arguments": {"gen_args_0": {"arg_0": "function cryptoJsDecrypt ( message , key , iv ) { assert ( message , \"Missing cipher text\" ) ; message = toBinaryBuffer ( message ) ; const decipher = crypto . createDecipheriv ( \"aes-256-cbc\" , key , iv ) ; // decipher.setAutoPadding(true) message = Buffer . concat ( [ decipher . update ( message ) , decipher . final ( ) ] ) ; return message ; }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["function toBinaryBuffer ( string ) { const buffer = new Uint"]], "filtered_resps": ["function toBinaryBuffer ( string ) { const buffer = new Uint"], "doc_hash": "39181d03f44a15447d8b57af2f4e763033791f8bff52563ba78fdea742b1c910", "prompt_hash": "18dae58294fc72c51f3fd0c98cd3b796b9d1c66ed4fc0be87f7323c40370c989", "target_hash": "a517119880294029dd1de3db6d2cfbbd5ae48e2a9fcc937e48ef3d8ce6f03cf8", "smoothed_bleu_4": 7.251567551399588e-77}
