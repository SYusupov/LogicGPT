{"doc_id": 0, "doc": {"id": 0, "repo": "etcd-io/etcd", "path": "clientv3/concurrency/stm.go", "func_name": "NewSTM", "original_string": "func NewSTM(c *v3.Client, apply func(STM) error, so ...stmOption) (*v3.TxnResponse, error) {\n\topts := &stmOptions{ctx: c.Ctx()}\n\tfor _, f := range so {\n\t\tf(opts)\n\t}\n\tif len(opts.prefetch) != 0 {\n\t\tf := apply\n\t\tapply = func(s STM) error {\n\t\t\ts.Get(opts.prefetch...)\n\t\t\treturn f(s)\n\t\t}\n\t}\n\treturn runSTM(mkSTM(c, opts), apply)\n}", "language": "go", "code": "func NewSTM(c *v3.Client, apply func(STM) error, so ...stmOption) (*v3.TxnResponse, error) {\n\topts := &stmOptions{ctx: c.Ctx()}\n\tfor _, f := range so {\n\t\tf(opts)\n\t}\n\tif len(opts.prefetch) != 0 {\n\t\tf := apply\n\t\tapply = func(s STM) error {\n\t\t\ts.Get(opts.prefetch...)\n\t\t\treturn f(s)\n\t\t}\n\t}\n\treturn runSTM(mkSTM(c, opts), apply)\n}", "code_tokens": ["func", "NewSTM", "(", "c", "*", "v3", ".", "Client", ",", "apply", "func", "(", "STM", ")", "error", ",", "so", "...", "stmOption", ")", "(", "*", "v3", ".", "TxnResponse", ",", "error", ")", "{", "opts", ":=", "&", "stmOptions", "{", "ctx", ":", "c", ".", "Ctx", "(", ")", "}", "\n", "for", "_", ",", "f", ":=", "range", "so", "{", "f", "(", "opts", ")", "\n", "}", "\n", "if", "len", "(", "opts", ".", "prefetch", ")", "!=", "0", "{", "f", ":=", "apply", "\n", "apply", "=", "func", "(", "s", "STM", ")", "error", "{", "s", ".", "Get", "(", "opts", ".", "prefetch", "...", ")", "\n", "return", "f", "(", "s", ")", "\n", "}", "\n", "}", "\n", "return", "runSTM", "(", "mkSTM", "(", "c", ",", "opts", ")", ",", "apply", ")", "\n", "}"], "docstring": "// NewSTM initiates a new STM instance, using serializable snapshot isolation by default.", "docstring_tokens": ["NewSTM", "initiates", "a", "new", "STM", "instance", "using", "serializable", "snapshot", "isolation", "by", "default", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/concurrency/stm.go#L89-L102"}, "target": "NewSTM initiates a new STM instance using serializable snapshot isolation by default .", "arguments": {"gen_args_0": {"arg_0": "func NewSTM ( c * v3 . Client , apply func ( STM ) error , so ... stmOption ) ( * v3 . TxnResponse , error ) { opts := & stmOptions { ctx : c . Ctx ( ) } for _ , f := range so { f ( opts ) } if len ( opts . prefetch ) != 0 { f := apply apply = func ( s STM ) error { s . Get ( opts . prefetch ... ) return f ( s ) } } return runSTM ( mkSTM ( c , opts ) , apply ) }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func runSTM ( stm STM , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { resp , err := stm . Commit ( ) if err != nil { return nil , err } return resp , apply ( stm ) } func mkSTM ( c * v3 . Client , opts * stmOptions ) STM { return & stm { c : c , opts : opts } } type stm struct { c * v3 . Client opts * stmOptions } func ( s stm ) Commit ( ) ( * v3 . TxnResponse"]], "filtered_resps": ["func runSTM ( stm STM , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { resp , err := stm . Commit ( ) if err != nil { return nil , err } return resp , apply ( stm ) } func mkSTM ( c * v3 . Client , opts * stmOptions ) STM { return & stm { c : c , opts : opts } } type stm struct { c * v3 . Client opts * stmOptions } func ( s stm ) Commit ( ) ( * v3 . TxnResponse"], "doc_hash": "a2636d099f3f77869750c6bc23bc04f4e0653c532d1267a2b403602f82b4ae32", "prompt_hash": "b35c20fa94b1275d15bef80eb4ce2c80bfb3f1dfbc5134a463b39f11f1466e85", "target_hash": "01b63d524d57a3ddb7973506efe4e8ce3c4c3c61534a8f3629dce9d2eb9a94ac", "smoothed_bleu_4": 1.1407624266922762}
{"doc_id": 1, "doc": {"id": 1, "repo": "etcd-io/etcd", "path": "clientv3/concurrency/stm.go", "func_name": "first", "original_string": "func (rs readSet) first() int64 {\n\tret := int64(math.MaxInt64 - 1)\n\tfor _, resp := range rs {\n\t\tif rev := resp.Header.Revision; rev < ret {\n\t\t\tret = rev\n\t\t}\n\t}\n\treturn ret\n}", "language": "go", "code": "func (rs readSet) first() int64 {\n\tret := int64(math.MaxInt64 - 1)\n\tfor _, resp := range rs {\n\t\tif rev := resp.Header.Revision; rev < ret {\n\t\t\tret = rev\n\t\t}\n\t}\n\treturn ret\n}", "code_tokens": ["func", "(", "rs", "readSet", ")", "first", "(", ")", "int64", "{", "ret", ":=", "int64", "(", "math", ".", "MaxInt64", "-", "1", ")", "\n", "for", "_", ",", "resp", ":=", "range", "rs", "{", "if", "rev", ":=", "resp", ".", "Header", ".", "Revision", ";", "rev", "<", "ret", "{", "ret", "=", "rev", "\n", "}", "\n", "}", "\n", "return", "ret", "\n", "}"], "docstring": "// first returns the store revision from the first fetch", "docstring_tokens": ["first", "returns", "the", "store", "revision", "from", "the", "first", "fetch"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/concurrency/stm.go#L197-L205"}, "target": "first returns the store revision from the first fetch", "arguments": {"gen_args_0": {"arg_0": "func ( rs readSet ) first ( ) int64 { ret := int64 ( math . MaxInt64 - 1 ) for _ , resp := range rs { if rev := resp . Header . Revision ; rev < ret { ret = rev } } return ret }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( rs readSet ) first ( ) uint64 { ret := uint64 ( math . MaxUint64 - 1 ) for _ , resp := range rs { if rev := resp . Header . Revision ; rev < ret { ret = rev } } return ret } func ( rs readSet ) first ( ) uint32 { ret := uint32 ( math . MaxUint32 - 1 ) for _ , resp := range rs { if rev := resp . Header . Revision ; rev < ret { ret = rev } } return ret } func ( rs readSet ) first ( ) uint"]], "filtered_resps": ["func ( rs readSet ) first ( ) uint64 { ret := uint64 ( math . MaxUint64 - 1 ) for _ , resp := range rs { if rev := resp . Header . Revision ; rev < ret { ret = rev } } return ret } func ( rs readSet ) first ( ) uint32 { ret := uint32 ( math . MaxUint32 - 1 ) for _ , resp := range rs { if rev := resp . Header . Revision ; rev < ret { ret = rev } } return ret } func ( rs readSet ) first ( ) uint"], "doc_hash": "baf4ec415b382b36799b4620bfd33b2294c042c9a2a626ad688621e06a686eb2", "prompt_hash": "6af15490b195741080c5e6dcea6dd572160052b8009f3e0e26b899249aa2837d", "target_hash": "671f2b6fb50d4525ed1babe04af5080a7f049182056bf672b2b07474270d59ca", "smoothed_bleu_4": 1.172481075192292}
{"doc_id": 2, "doc": {"id": 2, "repo": "etcd-io/etcd", "path": "clientv3/concurrency/stm.go", "func_name": "cmps", "original_string": "func (ws writeSet) cmps(rev int64) []v3.Cmp {\n\tcmps := make([]v3.Cmp, 0, len(ws))\n\tfor key := range ws {\n\t\tcmps = append(cmps, v3.Compare(v3.ModRevision(key), \"<\", rev))\n\t}\n\treturn cmps\n}", "language": "go", "code": "func (ws writeSet) cmps(rev int64) []v3.Cmp {\n\tcmps := make([]v3.Cmp, 0, len(ws))\n\tfor key := range ws {\n\t\tcmps = append(cmps, v3.Compare(v3.ModRevision(key), \"<\", rev))\n\t}\n\treturn cmps\n}", "code_tokens": ["func", "(", "ws", "writeSet", ")", "cmps", "(", "rev", "int64", ")", "[", "]", "v3", ".", "Cmp", "{", "cmps", ":=", "make", "(", "[", "]", "v3", ".", "Cmp", ",", "0", ",", "len", "(", "ws", ")", ")", "\n", "for", "key", ":=", "range", "ws", "{", "cmps", "=", "append", "(", "cmps", ",", "v3", ".", "Compare", "(", "v3", ".", "ModRevision", "(", "key", ")", ",", "\"", "\"", ",", "rev", ")", ")", "\n", "}", "\n", "return", "cmps", "\n", "}"], "docstring": "// cmps returns a cmp list testing no writes have happened past rev", "docstring_tokens": ["cmps", "returns", "a", "cmp", "list", "testing", "no", "writes", "have", "happened", "past", "rev"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/concurrency/stm.go#L228-L234"}, "target": "cmps returns a cmp list testing no writes have happened past rev", "arguments": {"gen_args_0": {"arg_0": "func ( ws writeSet ) cmps ( rev int64 ) [ ] v3 . Cmp { cmps := make ( [ ] v3 . Cmp , 0 , len ( ws ) ) for key := range ws { cmps = append ( cmps , v3 . Compare ( v3 . ModRevision ( key ) , \" \" , rev ) ) } return cmps }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( ws writeSet ) cmps ( rev int64 ) [ ] v3 . Cmp { cmps := make ( [ ] v3 . Cmp , 0 , len ( ws ) ) for key := range ws { cmps = append ( cmps , v3 . Compare ( v3 . ModRevision ( key ) , \" \" , rev ) ) } return cmps } func ( ws writeSet ) cmps ( rev int64 ) [ ] v3 . Cmp { cmps := make ( [ ] v3 . Cmp , 0 , len ("]], "filtered_resps": ["func ( ws writeSet ) cmps ( rev int64 ) [ ] v3 . Cmp { cmps := make ( [ ] v3 . Cmp , 0 , len ( ws ) ) for key := range ws { cmps = append ( cmps , v3 . Compare ( v3 . ModRevision ( key ) , \" \" , rev ) ) } return cmps } func ( ws writeSet ) cmps ( rev int64 ) [ ] v3 . Cmp { cmps := make ( [ ] v3 . Cmp , 0 , len ("], "doc_hash": "b6b88015d50c0325b253caf383cacdf436d30a4e24311c7e80ef83905661522d", "prompt_hash": "0a3fa129aabbb832116b09deb2d5f34597de57939aa82ce464d3a54dc45c0eee", "target_hash": "429b79207e80f879fbd1d80e3cc4b695c62fc4fa53b13934dd745c9521dde41c", "smoothed_bleu_4": 1.3395633716256328}
{"doc_id": 3, "doc": {"id": 3, "repo": "etcd-io/etcd", "path": "clientv3/concurrency/stm.go", "func_name": "NewSTMRepeatable", "original_string": "func NewSTMRepeatable(ctx context.Context, c *v3.Client, apply func(STM) error) (*v3.TxnResponse, error) {\n\treturn NewSTM(c, apply, WithAbortContext(ctx), WithIsolation(RepeatableReads))\n}", "language": "go", "code": "func NewSTMRepeatable(ctx context.Context, c *v3.Client, apply func(STM) error) (*v3.TxnResponse, error) {\n\treturn NewSTM(c, apply, WithAbortContext(ctx), WithIsolation(RepeatableReads))\n}", "code_tokens": ["func", "NewSTMRepeatable", "(", "ctx", "context", ".", "Context", ",", "c", "*", "v3", ".", "Client", ",", "apply", "func", "(", "STM", ")", "error", ")", "(", "*", "v3", ".", "TxnResponse", ",", "error", ")", "{", "return", "NewSTM", "(", "c", ",", "apply", ",", "WithAbortContext", "(", "ctx", ")", ",", "WithIsolation", "(", "RepeatableReads", ")", ")", "\n", "}"], "docstring": "// NewSTMRepeatable is deprecated.", "docstring_tokens": ["NewSTMRepeatable", "is", "deprecated", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/concurrency/stm.go#L375-L377"}, "target": "NewSTMRepeatable is deprecated .", "arguments": {"gen_args_0": {"arg_0": "func NewSTMRepeatable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( RepeatableReads ) ) }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func NewSTMRepeatable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( RepeatableReads ) ) } func NewSTMRepeatable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ("]], "filtered_resps": ["func NewSTMRepeatable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( RepeatableReads ) ) } func NewSTMRepeatable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ("], "doc_hash": "f54ed98637a4f236ef4c751fae0c0271e7a382e187f6015b9ad54980a2403f2e", "prompt_hash": "77154831d2efbf13acdb5cbcdcdfd451f031338b9a7d17dcd8f65bf420c8c3ab", "target_hash": "f4b7efa7c40b100158a779ea969fceb113da1a1f40075d4850f4c925a1cd4d0c", "smoothed_bleu_4": 1.303294641932591}
{"doc_id": 4, "doc": {"id": 4, "repo": "etcd-io/etcd", "path": "clientv3/concurrency/stm.go", "func_name": "NewSTMSerializable", "original_string": "func NewSTMSerializable(ctx context.Context, c *v3.Client, apply func(STM) error) (*v3.TxnResponse, error) {\n\treturn NewSTM(c, apply, WithAbortContext(ctx), WithIsolation(Serializable))\n}", "language": "go", "code": "func NewSTMSerializable(ctx context.Context, c *v3.Client, apply func(STM) error) (*v3.TxnResponse, error) {\n\treturn NewSTM(c, apply, WithAbortContext(ctx), WithIsolation(Serializable))\n}", "code_tokens": ["func", "NewSTMSerializable", "(", "ctx", "context", ".", "Context", ",", "c", "*", "v3", ".", "Client", ",", "apply", "func", "(", "STM", ")", "error", ")", "(", "*", "v3", ".", "TxnResponse", ",", "error", ")", "{", "return", "NewSTM", "(", "c", ",", "apply", ",", "WithAbortContext", "(", "ctx", ")", ",", "WithIsolation", "(", "Serializable", ")", ")", "\n", "}"], "docstring": "// NewSTMSerializable is deprecated.", "docstring_tokens": ["NewSTMSerializable", "is", "deprecated", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/concurrency/stm.go#L380-L382"}, "target": "NewSTMSerializable is deprecated .", "arguments": {"gen_args_0": {"arg_0": "func NewSTMSerializable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( Serializable ) ) }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func NewSTMSerializable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( Serializable ) ) } func NewSTMSerializable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( Serializable ) ) }"]], "filtered_resps": ["func NewSTMSerializable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( Serializable ) ) } func NewSTMSerializable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( Serializable ) ) }"], "doc_hash": "cf84459ce761a0c9059c71241921ee70057acac9e81c778197d447be5657fa1d", "prompt_hash": "c2757f40a0d0fb69cbf3069c60ca291a48effbf8a0f7e03f54cda3e868062712", "target_hash": "34965285c9505ec1c311f618ed1cb25ff875e398f40fc0cf77ac77212d972c51", "smoothed_bleu_4": 1.2485588509187513}
{"doc_id": 5, "doc": {"id": 5, "repo": "etcd-io/etcd", "path": "clientv3/concurrency/stm.go", "func_name": "NewSTMReadCommitted", "original_string": "func NewSTMReadCommitted(ctx context.Context, c *v3.Client, apply func(STM) error) (*v3.TxnResponse, error) {\n\treturn NewSTM(c, apply, WithAbortContext(ctx), WithIsolation(ReadCommitted))\n}", "language": "go", "code": "func NewSTMReadCommitted(ctx context.Context, c *v3.Client, apply func(STM) error) (*v3.TxnResponse, error) {\n\treturn NewSTM(c, apply, WithAbortContext(ctx), WithIsolation(ReadCommitted))\n}", "code_tokens": ["func", "NewSTMReadCommitted", "(", "ctx", "context", ".", "Context", ",", "c", "*", "v3", ".", "Client", ",", "apply", "func", "(", "STM", ")", "error", ")", "(", "*", "v3", ".", "TxnResponse", ",", "error", ")", "{", "return", "NewSTM", "(", "c", ",", "apply", ",", "WithAbortContext", "(", "ctx", ")", ",", "WithIsolation", "(", "ReadCommitted", ")", ")", "\n", "}"], "docstring": "// NewSTMReadCommitted is deprecated.", "docstring_tokens": ["NewSTMReadCommitted", "is", "deprecated", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/concurrency/stm.go#L385-L387"}, "target": "NewSTMReadCommitted is deprecated .", "arguments": {"gen_args_0": {"arg_0": "func NewSTMReadCommitted ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( ReadCommitted ) ) }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func NewSTMReadUncommitted ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( ReadUncommitted ) ) } func NewSTMSerializable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( Serial"]], "filtered_resps": ["func NewSTMReadUncommitted ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( ReadUncommitted ) ) } func NewSTMSerializable ( ctx context . Context , c * v3 . Client , apply func ( STM ) error ) ( * v3 . TxnResponse , error ) { return NewSTM ( c , apply , WithAbortContext ( ctx ) , WithIsolation ( Serial"], "doc_hash": "38b946e5e7ebdf732fc4e14d34a2021c264b2618c15bd90e2e67975777d42291", "prompt_hash": "ea968a693c113ddbfb39b36824d2ef47bbfec5abb566d41652fa6a0353759930", "target_hash": "d9d8ddc843326acc0d94f4112ccd4d0057c562014b4b7eb12a731fb4bae92a63", "smoothed_bleu_4": 1.0840547601878574}
{"doc_id": 6, "doc": {"id": 6, "repo": "etcd-io/etcd", "path": "pkg/tlsutil/tlsutil.go", "func_name": "NewCertPool", "original_string": "func NewCertPool(CAFiles []string) (*x509.CertPool, error) {\n\tcertPool := x509.NewCertPool()\n\n\tfor _, CAFile := range CAFiles {\n\t\tpemByte, err := ioutil.ReadFile(CAFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor {\n\t\t\tvar block *pem.Block\n\t\t\tblock, pemByte = pem.Decode(pemByte)\n\t\t\tif block == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcert, err := x509.ParseCertificate(block.Bytes)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tcertPool.AddCert(cert)\n\t\t}\n\t}\n\n\treturn certPool, nil\n}", "language": "go", "code": "func NewCertPool(CAFiles []string) (*x509.CertPool, error) {\n\tcertPool := x509.NewCertPool()\n\n\tfor _, CAFile := range CAFiles {\n\t\tpemByte, err := ioutil.ReadFile(CAFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor {\n\t\t\tvar block *pem.Block\n\t\t\tblock, pemByte = pem.Decode(pemByte)\n\t\t\tif block == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcert, err := x509.ParseCertificate(block.Bytes)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tcertPool.AddCert(cert)\n\t\t}\n\t}\n\n\treturn certPool, nil\n}", "code_tokens": ["func", "NewCertPool", "(", "CAFiles", "[", "]", "string", ")", "(", "*", "x509", ".", "CertPool", ",", "error", ")", "{", "certPool", ":=", "x509", ".", "NewCertPool", "(", ")", "\n\n", "for", "_", ",", "CAFile", ":=", "range", "CAFiles", "{", "pemByte", ",", "err", ":=", "ioutil", ".", "ReadFile", "(", "CAFile", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "for", "{", "var", "block", "*", "pem", ".", "Block", "\n", "block", ",", "pemByte", "=", "pem", ".", "Decode", "(", "pemByte", ")", "\n", "if", "block", "==", "nil", "{", "break", "\n", "}", "\n", "cert", ",", "err", ":=", "x509", ".", "ParseCertificate", "(", "block", ".", "Bytes", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "certPool", ".", "AddCert", "(", "cert", ")", "\n", "}", "\n", "}", "\n\n", "return", "certPool", ",", "nil", "\n", "}"], "docstring": "// NewCertPool creates x509 certPool with provided CA files.", "docstring_tokens": ["NewCertPool", "creates", "x509", "certPool", "with", "provided", "CA", "files", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/tlsutil/tlsutil.go#L25-L50"}, "target": "NewCertPool creates x509 certPool with provided CA files .", "arguments": {"gen_args_0": {"arg_0": "func NewCertPool ( CAFiles [ ] string ) ( * x509 . CertPool , error ) { certPool := x509 . NewCertPool ( ) for _ , CAFile := range CAFiles { pemByte , err := ioutil . ReadFile ( CAFile ) if err != nil { return nil , err } for { var block * pem . Block block , pemByte = pem . Decode ( pemByte ) if block == nil { break } cert , err := x509 . ParseCertificate ( block . Bytes ) if err != nil { return nil , err } certPool . AddCert ( cert ) } } return certPool , nil }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["\n\nfunc NewCertPool ( CAFiles [ ] string ) ( * x509 . CertPool , error ) { certPool := x509 . NewCertPool ( ) for _ , CAFile := range CAFiles { pemByte , err := ioutil . ReadFile ( CAFile ) if err != nil { return nil , err } for { var block * pem . Block block , pemByte = pem . Decode ( pemByte ) if block == nil { break } cert , err := x509 . ParseCertificate ( block . Bytes ) if err"]], "filtered_resps": ["\n\nfunc NewCertPool ( CAFiles [ ] string ) ( * x509 . CertPool , error ) { certPool := x509 . NewCertPool ( ) for _ , CAFile := range CAFiles { pemByte , err := ioutil . ReadFile ( CAFile ) if err != nil { return nil , err } for { var block * pem . Block block , pemByte = pem . Decode ( pemByte ) if block == nil { break } cert , err := x509 . ParseCertificate ( block . Bytes ) if err"], "doc_hash": "c40c9a09d309b3c4a75e8a73c353714de8920c4fa795e5ee4b163d0c15e706df", "prompt_hash": "9962f8f948cb9f21ccca60c08cc2b05392654bb9682b33c9f7e0fb527953b32f", "target_hash": "e1d676a7d0b87e64d4a12dd950aa87a812e3aa88b2a9f08068a22da4fce365b7", "smoothed_bleu_4": 1.4693674708493387}
{"doc_id": 7, "doc": {"id": 7, "repo": "etcd-io/etcd", "path": "pkg/tlsutil/tlsutil.go", "func_name": "NewCert", "original_string": "func NewCert(certfile, keyfile string, parseFunc func([]byte, []byte) (tls.Certificate, error)) (*tls.Certificate, error) {\n\tcert, err := ioutil.ReadFile(certfile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkey, err := ioutil.ReadFile(keyfile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif parseFunc == nil {\n\t\tparseFunc = tls.X509KeyPair\n\t}\n\n\ttlsCert, err := parseFunc(cert, key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &tlsCert, nil\n}", "language": "go", "code": "func NewCert(certfile, keyfile string, parseFunc func([]byte, []byte) (tls.Certificate, error)) (*tls.Certificate, error) {\n\tcert, err := ioutil.ReadFile(certfile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkey, err := ioutil.ReadFile(keyfile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif parseFunc == nil {\n\t\tparseFunc = tls.X509KeyPair\n\t}\n\n\ttlsCert, err := parseFunc(cert, key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &tlsCert, nil\n}", "code_tokens": ["func", "NewCert", "(", "certfile", ",", "keyfile", "string", ",", "parseFunc", "func", "(", "[", "]", "byte", ",", "[", "]", "byte", ")", "(", "tls", ".", "Certificate", ",", "error", ")", ")", "(", "*", "tls", ".", "Certificate", ",", "error", ")", "{", "cert", ",", "err", ":=", "ioutil", ".", "ReadFile", "(", "certfile", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "key", ",", "err", ":=", "ioutil", ".", "ReadFile", "(", "keyfile", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n\n", "if", "parseFunc", "==", "nil", "{", "parseFunc", "=", "tls", ".", "X509KeyPair", "\n", "}", "\n\n", "tlsCert", ",", "err", ":=", "parseFunc", "(", "cert", ",", "key", ")", "\n", "if", "err", "!=", "nil", "{", "return", "nil", ",", "err", "\n", "}", "\n", "return", "&", "tlsCert", ",", "nil", "\n", "}"], "docstring": "// NewCert generates TLS cert by using the given cert,key and parse function.", "docstring_tokens": ["NewCert", "generates", "TLS", "cert", "by", "using", "the", "given", "cert", "key", "and", "parse", "function", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/pkg/tlsutil/tlsutil.go#L53-L73"}, "target": "NewCert generates TLS cert by using the given cert key and parse function .", "arguments": {"gen_args_0": {"arg_0": "func NewCert ( certfile , keyfile string , parseFunc func ( [ ] byte , [ ] byte ) ( tls . Certificate , error ) ) ( * tls . Certificate , error ) { cert , err := ioutil . ReadFile ( certfile ) if err != nil { return nil , err } key , err := ioutil . ReadFile ( keyfile ) if err != nil { return nil , err } if parseFunc == nil { parseFunc = tls . X509KeyPair } tlsCert , err := parseFunc ( cert , key ) if err != nil { return nil , err } return & tlsCert , nil }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["\n\n```\nfunc NewCert ( certfile , keyfile string , parseFunc func ( [ ] byte , [ ] byte ) ( tls . Certificate , error ) ) ( * tls . Certificate , error ) { cert , err := ioutil . ReadFile ( certfile ) if err != nil { return nil , err } key , err := ioutil . ReadFile ( keyfile ) if err != nil { return nil , err } if parseFunc == nil { parseFunc = tls . X509KeyPair } tlsCert , err := parseFunc ( cert , key"]], "filtered_resps": ["\n\n```\nfunc NewCert ( certfile , keyfile string , parseFunc func ( [ ] byte , [ ] byte ) ( tls . Certificate , error ) ) ( * tls . Certificate , error ) { cert , err := ioutil . ReadFile ( certfile ) if err != nil { return nil , err } key , err := ioutil . ReadFile ( keyfile ) if err != nil { return nil , err } if parseFunc == nil { parseFunc = tls . X509KeyPair } tlsCert , err := parseFunc ( cert , key"], "doc_hash": "4e0444747c4ce95fdf2206cdf5fc560ab9f809a02000eecd629e794165083eeb", "prompt_hash": "05881f64cc84bed4656fa6b2217a49ffc0390fcef9b527d30451083c5fdd037d", "target_hash": "2d76f60fecc3cc1c0d5bf1c3b5e5133e54a1dfb135c3b1a11112f244d15d0826", "smoothed_bleu_4": 1.5013277847223268}
{"doc_id": 8, "doc": {"id": 8, "repo": "etcd-io/etcd", "path": "etcdserver/api/rafthttp/peer.go", "func_name": "Pause", "original_string": "func (p *peer) Pause() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.paused = true\n\tp.msgAppReader.pause()\n\tp.msgAppV2Reader.pause()\n}", "language": "go", "code": "func (p *peer) Pause() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.paused = true\n\tp.msgAppReader.pause()\n\tp.msgAppV2Reader.pause()\n}", "code_tokens": ["func", "(", "p", "*", "peer", ")", "Pause", "(", ")", "{", "p", ".", "mu", ".", "Lock", "(", ")", "\n", "defer", "p", ".", "mu", ".", "Unlock", "(", ")", "\n", "p", ".", "paused", "=", "true", "\n", "p", ".", "msgAppReader", ".", "pause", "(", ")", "\n", "p", ".", "msgAppV2Reader", ".", "pause", "(", ")", "\n", "}"], "docstring": "// Pause pauses the peer. The peer will simply drops all incoming\n// messages without returning an error.", "docstring_tokens": ["Pause", "pauses", "the", "peer", ".", "The", "peer", "will", "simply", "drops", "all", "incoming", "messages", "without", "returning", "an", "error", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/rafthttp/peer.go#L314-L320"}, "target": "Pause pauses the peer . The peer will simply drops all incoming messages without returning an error .", "arguments": {"gen_args_0": {"arg_0": "func ( p * peer ) Pause ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . paused = true p . msgAppReader . pause ( ) p . msgAppV2Reader . pause ( ) }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( p * peer ) Resume ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . paused = false p . msgAppReader . resume ( ) p . msgAppV2Reader . resume ( ) } func ( p * peer ) Stop ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . stopped = true p . msgAppReader . stop ( ) p . msgAppV2Reader . stop ( ) } func ( p * peer ) Start ( ) { p . mu . Lock ( ) defer p ."]], "filtered_resps": ["func ( p * peer ) Resume ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . paused = false p . msgAppReader . resume ( ) p . msgAppV2Reader . resume ( ) } func ( p * peer ) Stop ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . stopped = true p . msgAppReader . stop ( ) p . msgAppV2Reader . stop ( ) } func ( p * peer ) Start ( ) { p . mu . Lock ( ) defer p ."], "doc_hash": "4a8a0273259fe1173b99c795c852e75e4b2f359c76aebe9066a285e890e5d981", "prompt_hash": "87f81b4d3c9e9f6831246c4658a948953e311c140ad878f8696f22f8440cc5f6", "target_hash": "29c1339ffdc5b132662b32d70ac8173b51c99f17067b3458184818806ac2cc1c", "smoothed_bleu_4": 1.2945120335001759}
{"doc_id": 9, "doc": {"id": 9, "repo": "etcd-io/etcd", "path": "etcdserver/api/rafthttp/peer.go", "func_name": "Resume", "original_string": "func (p *peer) Resume() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.paused = false\n\tp.msgAppReader.resume()\n\tp.msgAppV2Reader.resume()\n}", "language": "go", "code": "func (p *peer) Resume() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.paused = false\n\tp.msgAppReader.resume()\n\tp.msgAppV2Reader.resume()\n}", "code_tokens": ["func", "(", "p", "*", "peer", ")", "Resume", "(", ")", "{", "p", ".", "mu", ".", "Lock", "(", ")", "\n", "defer", "p", ".", "mu", ".", "Unlock", "(", ")", "\n", "p", ".", "paused", "=", "false", "\n", "p", ".", "msgAppReader", ".", "resume", "(", ")", "\n", "p", ".", "msgAppV2Reader", ".", "resume", "(", ")", "\n", "}"], "docstring": "// Resume resumes a paused peer.", "docstring_tokens": ["Resume", "resumes", "a", "paused", "peer", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/rafthttp/peer.go#L323-L329"}, "target": "Resume resumes a paused peer .", "arguments": {"gen_args_0": {"arg_0": "func ( p * peer ) Resume ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . paused = false p . msgAppReader . resume ( ) p . msgAppV2Reader . resume ( ) }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( p * peer ) Pause ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . paused = true p . msgAppReader . pause ( ) p . msgAppV2Reader . pause ( ) } func ( p * peer ) Stop ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . msgAppReader . stop ( ) p . msgAppV2Reader . stop ( ) } func ( p * peer ) Close ( ) { p . mu . Lock ( ) defer p . mu . Unlock ("]], "filtered_resps": ["func ( p * peer ) Pause ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . paused = true p . msgAppReader . pause ( ) p . msgAppV2Reader . pause ( ) } func ( p * peer ) Stop ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . msgAppReader . stop ( ) p . msgAppV2Reader . stop ( ) } func ( p * peer ) Close ( ) { p . mu . Lock ( ) defer p . mu . Unlock ("], "doc_hash": "5954ba80abe376b92534694317bf82e8dd80149e1a3fda2dc13b5778da7e8a6c", "prompt_hash": "bb85657c8f09cc736cbb543a2eadab1d7905b41ef2bfd8c4451eb8f66e0cc403", "target_hash": "ae149d5b74b19530a95680c72033f0c31ec8516bfe09a7287c036db5063484e7", "smoothed_bleu_4": 1.2158085170875914}
{"doc_id": 10, "doc": {"id": 10, "repo": "etcd-io/etcd", "path": "etcdserver/api/rafthttp/peer.go", "func_name": "pick", "original_string": "func (p *peer) pick(m raftpb.Message) (writec chan<- raftpb.Message, picked string) {\n\tvar ok bool\n\t// Considering MsgSnap may have a big size, e.g., 1G, and will block\n\t// stream for a long time, only use one of the N pipelines to send MsgSnap.\n\tif isMsgSnap(m) {\n\t\treturn p.pipeline.msgc, pipelineMsg\n\t} else if writec, ok = p.msgAppV2Writer.writec(); ok && isMsgApp(m) {\n\t\treturn writec, streamAppV2\n\t} else if writec, ok = p.writer.writec(); ok {\n\t\treturn writec, streamMsg\n\t}\n\treturn p.pipeline.msgc, pipelineMsg\n}", "language": "go", "code": "func (p *peer) pick(m raftpb.Message) (writec chan<- raftpb.Message, picked string) {\n\tvar ok bool\n\t// Considering MsgSnap may have a big size, e.g., 1G, and will block\n\t// stream for a long time, only use one of the N pipelines to send MsgSnap.\n\tif isMsgSnap(m) {\n\t\treturn p.pipeline.msgc, pipelineMsg\n\t} else if writec, ok = p.msgAppV2Writer.writec(); ok && isMsgApp(m) {\n\t\treturn writec, streamAppV2\n\t} else if writec, ok = p.writer.writec(); ok {\n\t\treturn writec, streamMsg\n\t}\n\treturn p.pipeline.msgc, pipelineMsg\n}", "code_tokens": ["func", "(", "p", "*", "peer", ")", "pick", "(", "m", "raftpb", ".", "Message", ")", "(", "writec", "chan", "<-", "raftpb", ".", "Message", ",", "picked", "string", ")", "{", "var", "ok", "bool", "\n", "// Considering MsgSnap may have a big size, e.g., 1G, and will block", "// stream for a long time, only use one of the N pipelines to send MsgSnap.", "if", "isMsgSnap", "(", "m", ")", "{", "return", "p", ".", "pipeline", ".", "msgc", ",", "pipelineMsg", "\n", "}", "else", "if", "writec", ",", "ok", "=", "p", ".", "msgAppV2Writer", ".", "writec", "(", ")", ";", "ok", "&&", "isMsgApp", "(", "m", ")", "{", "return", "writec", ",", "streamAppV2", "\n", "}", "else", "if", "writec", ",", "ok", "=", "p", ".", "writer", ".", "writec", "(", ")", ";", "ok", "{", "return", "writec", ",", "streamMsg", "\n", "}", "\n", "return", "p", ".", "pipeline", ".", "msgc", ",", "pipelineMsg", "\n", "}"], "docstring": "// pick picks a chan for sending the given message. The picked chan and the picked chan\n// string name are returned.", "docstring_tokens": ["pick", "picks", "a", "chan", "for", "sending", "the", "given", "message", ".", "The", "picked", "chan", "and", "the", "picked", "chan", "string", "name", "are", "returned", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/rafthttp/peer.go#L358-L370"}, "target": "pick picks a chan for sending the given message . The picked chan and the picked chan string name are returned .", "arguments": {"gen_args_0": {"arg_0": "func ( p * peer ) pick ( m raftpb . Message ) ( writec chan <- raftpb . Message , picked string ) { var ok bool // Considering MsgSnap may have a big size, e.g., 1G, and will block // stream for a long time, only use one of the N pipelines to send MsgSnap. if isMsgSnap ( m ) { return p . pipeline . msgc , pipelineMsg } else if writec , ok = p . msgAppV2Writer . writec ( ) ; ok && isMsgApp ( m ) { return writec , streamAppV2 } else if writec , ok = p . writer . writec ( ) ; ok { return writec , streamMsg } return p . pipeline . msgc , pipelineMsg }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( p * peer ) pick ( m raftpb . Message ) ( writec chan <- raftpb . Message , picked string ) { var ok bool // Considering MsgSnap may have a big size, e.g., 1G, and will block // stream for a long time, only use one of the N pipelines to send MsgSnap. if isMsgSnap ( m ) { return p . pipeline . msgc , pipelineMsg } else if writec , ok = p . msgAppV2Writer . writec ( ) ; ok && isMsgApp ( m"]], "filtered_resps": ["func ( p * peer ) pick ( m raftpb . Message ) ( writec chan <- raftpb . Message , picked string ) { var ok bool // Considering MsgSnap may have a big size, e.g., 1G, and will block // stream for a long time, only use one of the N pipelines to send MsgSnap. if isMsgSnap ( m ) { return p . pipeline . msgc , pipelineMsg } else if writec , ok = p . msgAppV2Writer . writec ( ) ; ok && isMsgApp ( m"], "doc_hash": "923c1e7f11ca68e8c5878a4db3cbf90322faad2f96162219637d04e08db21f71", "prompt_hash": "717628ea654f07bc338b8954af24fcaadc3b9cf3ece1d323360e55c47000f1f6", "target_hash": "eb5e7a81ff89ae0620bea927ff77c347f8017c8f8e3d1599907ec9552e1dd3d4", "smoothed_bleu_4": 1.7811445753974278}
{"doc_id": 11, "doc": {"id": 11, "repo": "etcd-io/etcd", "path": "etcdserver/api/rafthttp/snapshot_sender.go", "func_name": "post", "original_string": "func (s *snapshotSender) post(req *http.Request) (err error) {\n\tctx, cancel := context.WithCancel(context.Background())\n\treq = req.WithContext(ctx)\n\tdefer cancel()\n\n\ttype responseAndError struct {\n\t\tresp *http.Response\n\t\tbody []byte\n\t\terr  error\n\t}\n\tresult := make(chan responseAndError, 1)\n\n\tgo func() {\n\t\tresp, err := s.tr.pipelineRt.RoundTrip(req)\n\t\tif err != nil {\n\t\t\tresult <- responseAndError{resp, nil, err}\n\t\t\treturn\n\t\t}\n\n\t\t// close the response body when timeouts.\n\t\t// prevents from reading the body forever when the other side dies right after\n\t\t// successfully receives the request body.\n\t\ttime.AfterFunc(snapResponseReadTimeout, func() { httputil.GracefulClose(resp) })\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tresult <- responseAndError{resp, body, err}\n\t}()\n\n\tselect {\n\tcase <-s.stopc:\n\t\treturn errStopped\n\tcase r := <-result:\n\t\tif r.err != nil {\n\t\t\treturn r.err\n\t\t}\n\t\treturn checkPostResponse(r.resp, r.body, req, s.to)\n\t}\n}", "language": "go", "code": "func (s *snapshotSender) post(req *http.Request) (err error) {\n\tctx, cancel := context.WithCancel(context.Background())\n\treq = req.WithContext(ctx)\n\tdefer cancel()\n\n\ttype responseAndError struct {\n\t\tresp *http.Response\n\t\tbody []byte\n\t\terr  error\n\t}\n\tresult := make(chan responseAndError, 1)\n\n\tgo func() {\n\t\tresp, err := s.tr.pipelineRt.RoundTrip(req)\n\t\tif err != nil {\n\t\t\tresult <- responseAndError{resp, nil, err}\n\t\t\treturn\n\t\t}\n\n\t\t// close the response body when timeouts.\n\t\t// prevents from reading the body forever when the other side dies right after\n\t\t// successfully receives the request body.\n\t\ttime.AfterFunc(snapResponseReadTimeout, func() { httputil.GracefulClose(resp) })\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tresult <- responseAndError{resp, body, err}\n\t}()\n\n\tselect {\n\tcase <-s.stopc:\n\t\treturn errStopped\n\tcase r := <-result:\n\t\tif r.err != nil {\n\t\t\treturn r.err\n\t\t}\n\t\treturn checkPostResponse(r.resp, r.body, req, s.to)\n\t}\n}", "code_tokens": ["func", "(", "s", "*", "snapshotSender", ")", "post", "(", "req", "*", "http", ".", "Request", ")", "(", "err", "error", ")", "{", "ctx", ",", "cancel", ":=", "context", ".", "WithCancel", "(", "context", ".", "Background", "(", ")", ")", "\n", "req", "=", "req", ".", "WithContext", "(", "ctx", ")", "\n", "defer", "cancel", "(", ")", "\n\n", "type", "responseAndError", "struct", "{", "resp", "*", "http", ".", "Response", "\n", "body", "[", "]", "byte", "\n", "err", "error", "\n", "}", "\n", "result", ":=", "make", "(", "chan", "responseAndError", ",", "1", ")", "\n\n", "go", "func", "(", ")", "{", "resp", ",", "err", ":=", "s", ".", "tr", ".", "pipelineRt", ".", "RoundTrip", "(", "req", ")", "\n", "if", "err", "!=", "nil", "{", "result", "<-", "responseAndError", "{", "resp", ",", "nil", ",", "err", "}", "\n", "return", "\n", "}", "\n\n", "// close the response body when timeouts.", "// prevents from reading the body forever when the other side dies right after", "// successfully receives the request body.", "time", ".", "AfterFunc", "(", "snapResponseReadTimeout", ",", "func", "(", ")", "{", "httputil", ".", "GracefulClose", "(", "resp", ")", "}", ")", "\n", "body", ",", "err", ":=", "ioutil", ".", "ReadAll", "(", "resp", ".", "Body", ")", "\n", "result", "<-", "responseAndError", "{", "resp", ",", "body", ",", "err", "}", "\n", "}", "(", ")", "\n\n", "select", "{", "case", "<-", "s", ".", "stopc", ":", "return", "errStopped", "\n", "case", "r", ":=", "<-", "result", ":", "if", "r", ".", "err", "!=", "nil", "{", "return", "r", ".", "err", "\n", "}", "\n", "return", "checkPostResponse", "(", "r", ".", "resp", ",", "r", ".", "body", ",", "req", ",", "s", ".", "to", ")", "\n", "}", "\n", "}"], "docstring": "// post posts the given request.\n// It returns nil when request is sent out and processed successfully.", "docstring_tokens": ["post", "posts", "the", "given", "request", ".", "It", "returns", "nil", "when", "request", "is", "sent", "out", "and", "processed", "successfully", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/rafthttp/snapshot_sender.go#L149-L185"}, "target": "post posts the given request . It returns nil when request is sent out and processed successfully .", "arguments": {"gen_args_0": {"arg_0": "func ( s * snapshotSender ) post ( req * http . Request ) ( err error ) { ctx , cancel := context . WithCancel ( context . Background ( ) ) req = req . WithContext ( ctx ) defer cancel ( ) type responseAndError struct { resp * http . Response body [ ] byte err error } result := make ( chan responseAndError , 1 ) go func ( ) { resp , err := s . tr . pipelineRt . RoundTrip ( req ) if err != nil { result <- responseAndError { resp , nil , err } return } // close the response body when timeouts. // prevents from reading the body forever when the other side dies right after // successfully receives the request body. time . AfterFunc ( snapResponseReadTimeout , func ( ) { httputil . GracefulClose ( resp ) } ) body , err := ioutil . ReadAll ( resp . Body ) result <- responseAndError { resp , body , err } } ( ) select { case <- s . stopc : return errStopped case r := <- result : if r . err != nil { return r . err } return checkPostResponse ( r . resp , r . body , req , s . to ) } }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( s * snapshotSender ) checkPostResponse ( resp * http . Response , body [ ] byte , req * http . Request , to * time . Time ) error { if resp . Status != http . StatusOK { return fmt .Errorf ( \"unexpected status: %s\", resp . Status ) } if resp . ContentLength != int64 ( len ( body ) ) { return fmt .Errorf ( \"unexpected content length: %d != %d\", resp . ContentLength , len ( body ) ) } if to != nil && time . Since ( resp . Header . Get ( \"Date\" ) )"]], "filtered_resps": ["func ( s * snapshotSender ) checkPostResponse ( resp * http . Response , body [ ] byte , req * http . Request , to * time . Time ) error { if resp . Status != http . StatusOK { return fmt .Errorf ( \"unexpected status: %s\", resp . Status ) } if resp . ContentLength != int64 ( len ( body ) ) { return fmt .Errorf ( \"unexpected content length: %d != %d\", resp . ContentLength , len ( body ) ) } if to != nil && time . Since ( resp . Header . Get ( \"Date\" ) )"], "doc_hash": "5553483f400ba6bd910c69c78f4804629c2144b22905e0d5556b4218573f0c11", "prompt_hash": "77bd45deee13ecc794d1076d7c9d6722c14150b5dc41a95485263fb2c430f30d", "target_hash": "071ba3ba331e1de0cfcfa3f20f2f915cef57980e71238dcbd98b65afbff03f66", "smoothed_bleu_4": 1.1382254506478615}
{"doc_id": 12, "doc": {"id": 12, "repo": "etcd-io/etcd", "path": "etcdserver/apply.go", "func_name": "newTxnResp", "original_string": "func newTxnResp(rt *pb.TxnRequest, txnPath []bool) (txnResp *pb.TxnResponse, txnCount int) {\n\treqs := rt.Success\n\tif !txnPath[0] {\n\t\treqs = rt.Failure\n\t}\n\tresps := make([]*pb.ResponseOp, len(reqs))\n\ttxnResp = &pb.TxnResponse{\n\t\tResponses: resps,\n\t\tSucceeded: txnPath[0],\n\t\tHeader:    &pb.ResponseHeader{},\n\t}\n\tfor i, req := range reqs {\n\t\tswitch tv := req.Request.(type) {\n\t\tcase *pb.RequestOp_RequestRange:\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponseRange{}}\n\t\tcase *pb.RequestOp_RequestPut:\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponsePut{}}\n\t\tcase *pb.RequestOp_RequestDeleteRange:\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponseDeleteRange{}}\n\t\tcase *pb.RequestOp_RequestTxn:\n\t\t\tresp, txns := newTxnResp(tv.RequestTxn, txnPath[1:])\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponseTxn{ResponseTxn: resp}}\n\t\t\ttxnPath = txnPath[1+txns:]\n\t\t\ttxnCount += txns + 1\n\t\tdefault:\n\t\t}\n\t}\n\treturn txnResp, txnCount\n}", "language": "go", "code": "func newTxnResp(rt *pb.TxnRequest, txnPath []bool) (txnResp *pb.TxnResponse, txnCount int) {\n\treqs := rt.Success\n\tif !txnPath[0] {\n\t\treqs = rt.Failure\n\t}\n\tresps := make([]*pb.ResponseOp, len(reqs))\n\ttxnResp = &pb.TxnResponse{\n\t\tResponses: resps,\n\t\tSucceeded: txnPath[0],\n\t\tHeader:    &pb.ResponseHeader{},\n\t}\n\tfor i, req := range reqs {\n\t\tswitch tv := req.Request.(type) {\n\t\tcase *pb.RequestOp_RequestRange:\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponseRange{}}\n\t\tcase *pb.RequestOp_RequestPut:\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponsePut{}}\n\t\tcase *pb.RequestOp_RequestDeleteRange:\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponseDeleteRange{}}\n\t\tcase *pb.RequestOp_RequestTxn:\n\t\t\tresp, txns := newTxnResp(tv.RequestTxn, txnPath[1:])\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponseTxn{ResponseTxn: resp}}\n\t\t\ttxnPath = txnPath[1+txns:]\n\t\t\ttxnCount += txns + 1\n\t\tdefault:\n\t\t}\n\t}\n\treturn txnResp, txnCount\n}", "code_tokens": ["func", "newTxnResp", "(", "rt", "*", "pb", ".", "TxnRequest", ",", "txnPath", "[", "]", "bool", ")", "(", "txnResp", "*", "pb", ".", "TxnResponse", ",", "txnCount", "int", ")", "{", "reqs", ":=", "rt", ".", "Success", "\n", "if", "!", "txnPath", "[", "0", "]", "{", "reqs", "=", "rt", ".", "Failure", "\n", "}", "\n", "resps", ":=", "make", "(", "[", "]", "*", "pb", ".", "ResponseOp", ",", "len", "(", "reqs", ")", ")", "\n", "txnResp", "=", "&", "pb", ".", "TxnResponse", "{", "Responses", ":", "resps", ",", "Succeeded", ":", "txnPath", "[", "0", "]", ",", "Header", ":", "&", "pb", ".", "ResponseHeader", "{", "}", ",", "}", "\n", "for", "i", ",", "req", ":=", "range", "reqs", "{", "switch", "tv", ":=", "req", ".", "Request", ".", "(", "type", ")", "{", "case", "*", "pb", ".", "RequestOp_RequestRange", ":", "resps", "[", "i", "]", "=", "&", "pb", ".", "ResponseOp", "{", "Response", ":", "&", "pb", ".", "ResponseOp_ResponseRange", "{", "}", "}", "\n", "case", "*", "pb", ".", "RequestOp_RequestPut", ":", "resps", "[", "i", "]", "=", "&", "pb", ".", "ResponseOp", "{", "Response", ":", "&", "pb", ".", "ResponseOp_ResponsePut", "{", "}", "}", "\n", "case", "*", "pb", ".", "RequestOp_RequestDeleteRange", ":", "resps", "[", "i", "]", "=", "&", "pb", ".", "ResponseOp", "{", "Response", ":", "&", "pb", ".", "ResponseOp_ResponseDeleteRange", "{", "}", "}", "\n", "case", "*", "pb", ".", "RequestOp_RequestTxn", ":", "resp", ",", "txns", ":=", "newTxnResp", "(", "tv", ".", "RequestTxn", ",", "txnPath", "[", "1", ":", "]", ")", "\n", "resps", "[", "i", "]", "=", "&", "pb", ".", "ResponseOp", "{", "Response", ":", "&", "pb", ".", "ResponseOp_ResponseTxn", "{", "ResponseTxn", ":", "resp", "}", "}", "\n", "txnPath", "=", "txnPath", "[", "1", "+", "txns", ":", "]", "\n", "txnCount", "+=", "txns", "+", "1", "\n", "default", ":", "}", "\n", "}", "\n", "return", "txnResp", ",", "txnCount", "\n", "}"], "docstring": "// newTxnResp allocates a txn response for a txn request given a path.", "docstring_tokens": ["newTxnResp", "allocates", "a", "txn", "response", "for", "a", "txn", "request", "given", "a", "path", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/apply.go#L381-L409"}, "target": "newTxnResp allocates a txn response for a txn request given a path .", "arguments": {"gen_args_0": {"arg_0": "func newTxnResp ( rt * pb . TxnRequest , txnPath [ ] bool ) ( txnResp * pb . TxnResponse , txnCount int ) { reqs := rt . Success if ! txnPath [ 0 ] { reqs = rt . Failure } resps := make ( [ ] * pb . ResponseOp , len ( reqs ) ) txnResp = & pb . TxnResponse { Responses : resps , Succeeded : txnPath [ 0 ] , Header : & pb . ResponseHeader { } , } for i , req := range reqs { switch tv := req . Request . ( type ) { case * pb . RequestOp_RequestRange : resps [ i ] = & pb . ResponseOp { Response : & pb . ResponseOp_ResponseRange { } } case * pb . RequestOp_RequestPut : resps [ i ] = & pb . ResponseOp { Response : & pb . ResponseOp_ResponsePut { } } case * pb . RequestOp_RequestDeleteRange : resps [ i ] = & pb . ResponseOp { Response : & pb . ResponseOp_ResponseDeleteRange { } } case * pb . RequestOp_RequestTxn : resp , txns := newTxnResp ( tv . RequestTxn , txnPath [ 1 : ] ) resps [ i ] = & pb . ResponseOp { Response : & pb . ResponseOp_ResponseTxn { ResponseTxn : resp } } txnPath = txnPath [ 1 + txns : ] txnCount += txns + 1 default : } } return txnResp , txnCount }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func newTxnResp ( rt * pb . TxnRequest , txnPath [ ] bool ) ( txnResp * pb . TxnResponse , txnCount int ) { reqs := rt . Success if ! txnPath [ 0 ] { reqs = rt . Failure } resps := make ( [ ] * pb . ResponseOp , len ( reqs ) ) txnResp = & pb . TxnResponse { Responses : resps , Succeeded : txnPath [ 0 ] , Header : & pb . ResponseHeader { } ,"]], "filtered_resps": ["func newTxnResp ( rt * pb . TxnRequest , txnPath [ ] bool ) ( txnResp * pb . TxnResponse , txnCount int ) { reqs := rt . Success if ! txnPath [ 0 ] { reqs = rt . Failure } resps := make ( [ ] * pb . ResponseOp , len ( reqs ) ) txnResp = & pb . TxnResponse { Responses : resps , Succeeded : txnPath [ 0 ] , Header : & pb . ResponseHeader { } ,"], "doc_hash": "8f66206ac0f9f538e2aa5011a340f549876d3fd51a50bd7179ab1a47afb43395", "prompt_hash": "2f00eda5a402e5c1c25c5a9f6c3b6d637868ee62a22ff1b4fc3b117db7249bff", "target_hash": "60de9507e8de6d2a9098958f8ee0422377db8e47d6bbff9897ba2ca3a39c2488", "smoothed_bleu_4": 1.3630498423423174}
{"doc_id": 13, "doc": {"id": 13, "repo": "etcd-io/etcd", "path": "etcdserver/apply.go", "func_name": "applyCompare", "original_string": "func applyCompare(rv mvcc.ReadView, c *pb.Compare) bool {\n\t// TODO: possible optimizations\n\t// * chunk reads for large ranges to conserve memory\n\t// * rewrite rules for common patterns:\n\t//\tex. \"[a, b) createrev > 0\" => \"limit 1 /\\ kvs > 0\"\n\t// * caching\n\trr, err := rv.Range(c.Key, mkGteRange(c.RangeEnd), mvcc.RangeOptions{})\n\tif err != nil {\n\t\treturn false\n\t}\n\tif len(rr.KVs) == 0 {\n\t\tif c.Target == pb.Compare_VALUE {\n\t\t\t// Always fail if comparing a value on a key/keys that doesn't exist;\n\t\t\t// nil == empty string in grpc; no way to represent missing value\n\t\t\treturn false\n\t\t}\n\t\treturn compareKV(c, mvccpb.KeyValue{})\n\t}\n\tfor _, kv := range rr.KVs {\n\t\tif !compareKV(c, kv) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "language": "go", "code": "func applyCompare(rv mvcc.ReadView, c *pb.Compare) bool {\n\t// TODO: possible optimizations\n\t// * chunk reads for large ranges to conserve memory\n\t// * rewrite rules for common patterns:\n\t//\tex. \"[a, b) createrev > 0\" => \"limit 1 /\\ kvs > 0\"\n\t// * caching\n\trr, err := rv.Range(c.Key, mkGteRange(c.RangeEnd), mvcc.RangeOptions{})\n\tif err != nil {\n\t\treturn false\n\t}\n\tif len(rr.KVs) == 0 {\n\t\tif c.Target == pb.Compare_VALUE {\n\t\t\t// Always fail if comparing a value on a key/keys that doesn't exist;\n\t\t\t// nil == empty string in grpc; no way to represent missing value\n\t\t\treturn false\n\t\t}\n\t\treturn compareKV(c, mvccpb.KeyValue{})\n\t}\n\tfor _, kv := range rr.KVs {\n\t\tif !compareKV(c, kv) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "code_tokens": ["func", "applyCompare", "(", "rv", "mvcc", ".", "ReadView", ",", "c", "*", "pb", ".", "Compare", ")", "bool", "{", "// TODO: possible optimizations", "// * chunk reads for large ranges to conserve memory", "// * rewrite rules for common patterns:", "//\tex. \"[a, b) createrev > 0\" => \"limit 1 /\\ kvs > 0\"", "// * caching", "rr", ",", "err", ":=", "rv", ".", "Range", "(", "c", ".", "Key", ",", "mkGteRange", "(", "c", ".", "RangeEnd", ")", ",", "mvcc", ".", "RangeOptions", "{", "}", ")", "\n", "if", "err", "!=", "nil", "{", "return", "false", "\n", "}", "\n", "if", "len", "(", "rr", ".", "KVs", ")", "==", "0", "{", "if", "c", ".", "Target", "==", "pb", ".", "Compare_VALUE", "{", "// Always fail if comparing a value on a key/keys that doesn't exist;", "// nil == empty string in grpc; no way to represent missing value", "return", "false", "\n", "}", "\n", "return", "compareKV", "(", "c", ",", "mvccpb", ".", "KeyValue", "{", "}", ")", "\n", "}", "\n", "for", "_", ",", "kv", ":=", "range", "rr", ".", "KVs", "{", "if", "!", "compareKV", "(", "c", ",", "kv", ")", "{", "return", "false", "\n", "}", "\n", "}", "\n", "return", "true", "\n", "}"], "docstring": "// applyCompare applies the compare request.\n// If the comparison succeeds, it returns true. Otherwise, returns false.", "docstring_tokens": ["applyCompare", "applies", "the", "compare", "request", ".", "If", "the", "comparison", "succeeds", "it", "returns", "true", ".", "Otherwise", "returns", "false", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/apply.go#L438-L462"}, "target": "applyCompare applies the compare request . If the comparison succeeds it returns true . Otherwise returns false .", "arguments": {"gen_args_0": {"arg_0": "func applyCompare ( rv mvcc . ReadView , c * pb . Compare ) bool { // TODO: possible optimizations // * chunk reads for large ranges to conserve memory // * rewrite rules for common patterns: // ex. \"[a, b) createrev > 0\" => \"limit 1 /\\ kvs > 0\" // * caching rr , err := rv . Range ( c . Key , mkGteRange ( c . RangeEnd ) , mvcc . RangeOptions { } ) if err != nil { return false } if len ( rr . KVs ) == 0 { if c . Target == pb . Compare_VALUE { // Always fail if comparing a value on a key/keys that doesn't exist; // nil == empty string in grpc; no way to represent missing value return false } return compareKV ( c , mvccpb . KeyValue { } ) } for _ , kv := range rr . KVs { if ! compareKV ( c , kv ) { return false } } return true }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func applyCompare ( rv mvcc . ReadView , c * pb . Compare ) bool { // TODO: possible optimizations // * chunk reads for large ranges to conserve memory // * rewrite rules for common patterns: // ex. \"[a, b) createrev > 0\" => \"limit 1 /\\ kvs > 0\" // * caching rr , err := rv . Range ( c . Key , mkGteRange ( c . RangeEnd ) , mvcc . RangeOptions { } ) if err != nil { return false } if len ( rr . KV"]], "filtered_resps": ["func applyCompare ( rv mvcc . ReadView , c * pb . Compare ) bool { // TODO: possible optimizations // * chunk reads for large ranges to conserve memory // * rewrite rules for common patterns: // ex. \"[a, b) createrev > 0\" => \"limit 1 /\\ kvs > 0\" // * caching rr , err := rv . Range ( c . Key , mkGteRange ( c . RangeEnd ) , mvcc . RangeOptions { } ) if err != nil { return false } if len ( rr . KV"], "doc_hash": "5d21a3490fff1636a5083bb93f6eb7e982dde5b705229f41d24bde0102f62f9e", "prompt_hash": "d2d7605b24be6c7061d38b6f22d8a4777044303f01edd5d6d70834bb8e98d350", "target_hash": "0d1bdec7c24117556b4582da0bd19ea76c8f3b3673f6aabfcbba864a827ab867", "smoothed_bleu_4": 1.4621320018986483}
{"doc_id": 14, "doc": {"id": 14, "repo": "etcd-io/etcd", "path": "clientv3/compact_op.go", "func_name": "OpCompact", "original_string": "func OpCompact(rev int64, opts ...CompactOption) CompactOp {\n\tret := CompactOp{revision: rev}\n\tret.applyCompactOpts(opts)\n\treturn ret\n}", "language": "go", "code": "func OpCompact(rev int64, opts ...CompactOption) CompactOp {\n\tret := CompactOp{revision: rev}\n\tret.applyCompactOpts(opts)\n\treturn ret\n}", "code_tokens": ["func", "OpCompact", "(", "rev", "int64", ",", "opts", "...", "CompactOption", ")", "CompactOp", "{", "ret", ":=", "CompactOp", "{", "revision", ":", "rev", "}", "\n", "ret", ".", "applyCompactOpts", "(", "opts", ")", "\n", "return", "ret", "\n", "}"], "docstring": "// OpCompact wraps slice CompactOption to create a CompactOp.", "docstring_tokens": ["OpCompact", "wraps", "slice", "CompactOption", "to", "create", "a", "CompactOp", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/clientv3/compact_op.go#L37-L41"}, "target": "OpCompact wraps slice CompactOption to create a CompactOp .", "arguments": {"gen_args_0": {"arg_0": "func OpCompact ( rev int64 , opts ... CompactOption ) CompactOp { ret := CompactOp { revision : rev } ret . applyCompactOpts ( opts ) return ret }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( op CompactOp ) applyCompactOpts ( opts ... CompactOption ) { for _, opt := range opts { opt ( &op ) } } func ( op CompactOp ) applyCompactOpts ( opts ... CompactOption ) { for _, opt := range opts { opt ( &op ) } } func ( op CompactOp ) applyCompactOpts ( opts ... CompactOption ) { for _, opt := range opts { opt ( &op ) } } func ( op CompactOp ) applyCompactOpts ( opts ... CompactOption ) { for _, opt := range opts { opt ( &"]], "filtered_resps": ["func ( op CompactOp ) applyCompactOpts ( opts ... CompactOption ) { for _, opt := range opts { opt ( &op ) } } func ( op CompactOp ) applyCompactOpts ( opts ... CompactOption ) { for _, opt := range opts { opt ( &op ) } } func ( op CompactOp ) applyCompactOpts ( opts ... CompactOption ) { for _, opt := range opts { opt ( &op ) } } func ( op CompactOp ) applyCompactOpts ( opts ... CompactOption ) { for _, opt := range opts { opt ( &"], "doc_hash": "e8a7c9d69a253ffb1648fb35db1a7c4bbc81fc75bfa12ec294cdbcfcf937f6d0", "prompt_hash": "f20e2956a4fb964d548004d6aa407441a1a0176a6525d588dc9d413ca0cb31d1", "target_hash": "c55a85d7cad3c5204b39f6717175ec69b100331ba15fa09afe6e2543e15a6594", "smoothed_bleu_4": 1.1419593537214163}
{"doc_id": 15, "doc": {"id": 15, "repo": "etcd-io/etcd", "path": "contrib/recipes/priority_queue.go", "func_name": "NewPriorityQueue", "original_string": "func NewPriorityQueue(client *v3.Client, key string) *PriorityQueue {\n\treturn &PriorityQueue{client, context.TODO(), key + \"/\"}\n}", "language": "go", "code": "func NewPriorityQueue(client *v3.Client, key string) *PriorityQueue {\n\treturn &PriorityQueue{client, context.TODO(), key + \"/\"}\n}", "code_tokens": ["func", "NewPriorityQueue", "(", "client", "*", "v3", ".", "Client", ",", "key", "string", ")", "*", "PriorityQueue", "{", "return", "&", "PriorityQueue", "{", "client", ",", "context", ".", "TODO", "(", ")", ",", "key", "+", "\"", "\"", "}", "\n", "}"], "docstring": "// NewPriorityQueue creates an etcd priority queue.", "docstring_tokens": ["NewPriorityQueue", "creates", "an", "etcd", "priority", "queue", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/contrib/recipes/priority_queue.go#L33-L35"}, "target": "NewPriorityQueue creates an etcd priority queue .", "arguments": {"gen_args_0": {"arg_0": "func NewPriorityQueue ( client * v3 . Client , key string ) * PriorityQueue { return & PriorityQueue { client , context . TODO ( ) , key + \" \" } }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( pq * PriorityQueue ) Push ( p * Priority ) error { return pq . client . PriorityQueue . Push ( pq . context , pq . key , p ) } func ( pq * PriorityQueue ) Pop ( ) ( * Priority , error ) { return pq . client . PriorityQueue . Pop ( pq . context ) } func ( pq * PriorityQueue ) Len ( ) int { return pq . client . PriorityQueue . Len ( pq . context ) } func ( pq * PriorityQueue ) Empty ( )"]], "filtered_resps": ["func ( pq * PriorityQueue ) Push ( p * Priority ) error { return pq . client . PriorityQueue . Push ( pq . context , pq . key , p ) } func ( pq * PriorityQueue ) Pop ( ) ( * Priority , error ) { return pq . client . PriorityQueue . Pop ( pq . context ) } func ( pq * PriorityQueue ) Len ( ) int { return pq . client . PriorityQueue . Len ( pq . context ) } func ( pq * PriorityQueue ) Empty ( )"], "doc_hash": "885b35a7fdab05091eccf8e32c8f61c2be1c0528158a261a0f25e52c5f11dbf9", "prompt_hash": "0aec3335af4e919f9d0fc510216bf25d0c1def868259253a9ed88f5e61b46595", "target_hash": "856e269918996eff38da3ef5e7814dbe1d19bd66bdc1d429fbac780a7c2e5a78", "smoothed_bleu_4": 1.2228796536652076}
{"doc_id": 16, "doc": {"id": 16, "repo": "etcd-io/etcd", "path": "contrib/recipes/priority_queue.go", "func_name": "Enqueue", "original_string": "func (q *PriorityQueue) Enqueue(val string, pr uint16) error {\n\tprefix := fmt.Sprintf(\"%s%05d\", q.key, pr)\n\t_, err := newSequentialKV(q.client, prefix, val)\n\treturn err\n}", "language": "go", "code": "func (q *PriorityQueue) Enqueue(val string, pr uint16) error {\n\tprefix := fmt.Sprintf(\"%s%05d\", q.key, pr)\n\t_, err := newSequentialKV(q.client, prefix, val)\n\treturn err\n}", "code_tokens": ["func", "(", "q", "*", "PriorityQueue", ")", "Enqueue", "(", "val", "string", ",", "pr", "uint16", ")", "error", "{", "prefix", ":=", "fmt", ".", "Sprintf", "(", "\"", "\"", ",", "q", ".", "key", ",", "pr", ")", "\n", "_", ",", "err", ":=", "newSequentialKV", "(", "q", ".", "client", ",", "prefix", ",", "val", ")", "\n", "return", "err", "\n", "}"], "docstring": "// Enqueue puts a value into a queue with a given priority.", "docstring_tokens": ["Enqueue", "puts", "a", "value", "into", "a", "queue", "with", "a", "given", "priority", "."], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/contrib/recipes/priority_queue.go#L38-L42"}, "target": "Enqueue puts a value into a queue with a given priority .", "arguments": {"gen_args_0": {"arg_0": "func ( q * PriorityQueue ) Enqueue ( val string , pr uint16 ) error { prefix := fmt . Sprintf ( \" \" , q . key , pr ) _ , err := newSequentialKV ( q . client , prefix , val ) return err }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( q * PriorityQueue ) Dequeue ( ) ( string , uint16 , error ) { prefix := fmt . Sprintf ( \" \" , q . key , 0 ) _ , val , err := newSequentialKV ( q . client , prefix , \"\" ) return val , 0 , err } func ( q * PriorityQueue ) Len ( ) int { prefix := fmt . Sprintf ( \" \" , q . key , 0 ) _ , val , err := newSequentialKV ( q . client , prefix , \"\" ) if err != nil { return 0 }"]], "filtered_resps": ["func ( q * PriorityQueue ) Dequeue ( ) ( string , uint16 , error ) { prefix := fmt . Sprintf ( \" \" , q . key , 0 ) _ , val , err := newSequentialKV ( q . client , prefix , \"\" ) return val , 0 , err } func ( q * PriorityQueue ) Len ( ) int { prefix := fmt . Sprintf ( \" \" , q . key , 0 ) _ , val , err := newSequentialKV ( q . client , prefix , \"\" ) if err != nil { return 0 }"], "doc_hash": "5a61b1bb939ca1cccaf249d39f6b88dd4f014a75c8c258d5bc60af45d3de5245", "prompt_hash": "0f35b2c7fcf825576a7fb29660c9d35c35ad8ef4ee79a4c62d31960b96e5f2b5", "target_hash": "13e2be130c36515b16d3b68d05b672bf7418ddad113c7999c3634f9a180873ba", "smoothed_bleu_4": 0.8989014328182042}
{"doc_id": 17, "doc": {"id": 17, "repo": "etcd-io/etcd", "path": "etcdserver/api/v2stats/leader.go", "func_name": "NewLeaderStats", "original_string": "func NewLeaderStats(id string) *LeaderStats {\n\treturn &LeaderStats{\n\t\tleaderStats: leaderStats{\n\t\t\tLeader:    id,\n\t\t\tFollowers: make(map[string]*FollowerStats),\n\t\t},\n\t}\n}", "language": "go", "code": "func NewLeaderStats(id string) *LeaderStats {\n\treturn &LeaderStats{\n\t\tleaderStats: leaderStats{\n\t\t\tLeader:    id,\n\t\t\tFollowers: make(map[string]*FollowerStats),\n\t\t},\n\t}\n}", "code_tokens": ["func", "NewLeaderStats", "(", "id", "string", ")", "*", "LeaderStats", "{", "return", "&", "LeaderStats", "{", "leaderStats", ":", "leaderStats", "{", "Leader", ":", "id", ",", "Followers", ":", "make", "(", "map", "[", "string", "]", "*", "FollowerStats", ")", ",", "}", ",", "}", "\n", "}"], "docstring": "// NewLeaderStats generates a new LeaderStats with the given id as leader", "docstring_tokens": ["NewLeaderStats", "generates", "a", "new", "LeaderStats", "with", "the", "given", "id", "as", "leader"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v2stats/leader.go#L39-L46"}, "target": "NewLeaderStats generates a new LeaderStats with the given id as leader", "arguments": {"gen_args_0": {"arg_0": "func NewLeaderStats ( id string ) * LeaderStats { return & LeaderStats { leaderStats : leaderStats { Leader : id , Followers : make ( map [ string ] * FollowerStats ) , } , } }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( ls * LeaderStats ) GetLeader () string { return ls . leaderStats . Leader } func ( ls * LeaderStats ) GetFollowers () map [ string ] * FollowerStats { return ls . leaderStats . Followers } func ( ls * LeaderStats ) AddFollower ( id string , fs * FollowerStats ) { ls . leaderStats . Followers [ id ] = fs } func ( ls * LeaderStats ) RemoveFollower ( id string ) { delete ( ls . leaderStats . Followers , id ) } func ( ls"]], "filtered_resps": ["func ( ls * LeaderStats ) GetLeader () string { return ls . leaderStats . Leader } func ( ls * LeaderStats ) GetFollowers () map [ string ] * FollowerStats { return ls . leaderStats . Followers } func ( ls * LeaderStats ) AddFollower ( id string , fs * FollowerStats ) { ls . leaderStats . Followers [ id ] = fs } func ( ls * LeaderStats ) RemoveFollower ( id string ) { delete ( ls . leaderStats . Followers , id ) } func ( ls"], "doc_hash": "c9af1f2740f03af496f4196d55ac7030985be4c55812ff86350498f17525da92", "prompt_hash": "87656d160ca5c267876cf5b06f5e55b9cdcb9c5189095d532ec329ed35401318", "target_hash": "63da199ed48cfb66c360ee27349cab6dd9e6ed2cff2d48378184d7f801d4f09f", "smoothed_bleu_4": 1.4113953845671645}
{"doc_id": 18, "doc": {"id": 18, "repo": "etcd-io/etcd", "path": "etcdserver/api/v2stats/leader.go", "func_name": "Succ", "original_string": "func (fs *FollowerStats) Succ(d time.Duration) {\n\tfs.Lock()\n\tdefer fs.Unlock()\n\n\ttotal := float64(fs.Counts.Success) * fs.Latency.Average\n\ttotalSquare := float64(fs.Counts.Success) * fs.Latency.averageSquare\n\n\tfs.Counts.Success++\n\n\tfs.Latency.Current = float64(d) / (1000000.0)\n\n\tif fs.Latency.Current > fs.Latency.Maximum {\n\t\tfs.Latency.Maximum = fs.Latency.Current\n\t}\n\n\tif fs.Latency.Current < fs.Latency.Minimum {\n\t\tfs.Latency.Minimum = fs.Latency.Current\n\t}\n\n\tfs.Latency.Average = (total + fs.Latency.Current) / float64(fs.Counts.Success)\n\tfs.Latency.averageSquare = (totalSquare + fs.Latency.Current*fs.Latency.Current) / float64(fs.Counts.Success)\n\n\t// sdv = sqrt(avg(x^2) - avg(x)^2)\n\tfs.Latency.StandardDeviation = math.Sqrt(fs.Latency.averageSquare - fs.Latency.Average*fs.Latency.Average)\n}", "language": "go", "code": "func (fs *FollowerStats) Succ(d time.Duration) {\n\tfs.Lock()\n\tdefer fs.Unlock()\n\n\ttotal := float64(fs.Counts.Success) * fs.Latency.Average\n\ttotalSquare := float64(fs.Counts.Success) * fs.Latency.averageSquare\n\n\tfs.Counts.Success++\n\n\tfs.Latency.Current = float64(d) / (1000000.0)\n\n\tif fs.Latency.Current > fs.Latency.Maximum {\n\t\tfs.Latency.Maximum = fs.Latency.Current\n\t}\n\n\tif fs.Latency.Current < fs.Latency.Minimum {\n\t\tfs.Latency.Minimum = fs.Latency.Current\n\t}\n\n\tfs.Latency.Average = (total + fs.Latency.Current) / float64(fs.Counts.Success)\n\tfs.Latency.averageSquare = (totalSquare + fs.Latency.Current*fs.Latency.Current) / float64(fs.Counts.Success)\n\n\t// sdv = sqrt(avg(x^2) - avg(x)^2)\n\tfs.Latency.StandardDeviation = math.Sqrt(fs.Latency.averageSquare - fs.Latency.Average*fs.Latency.Average)\n}", "code_tokens": ["func", "(", "fs", "*", "FollowerStats", ")", "Succ", "(", "d", "time", ".", "Duration", ")", "{", "fs", ".", "Lock", "(", ")", "\n", "defer", "fs", ".", "Unlock", "(", ")", "\n\n", "total", ":=", "float64", "(", "fs", ".", "Counts", ".", "Success", ")", "*", "fs", ".", "Latency", ".", "Average", "\n", "totalSquare", ":=", "float64", "(", "fs", ".", "Counts", ".", "Success", ")", "*", "fs", ".", "Latency", ".", "averageSquare", "\n\n", "fs", ".", "Counts", ".", "Success", "++", "\n\n", "fs", ".", "Latency", ".", "Current", "=", "float64", "(", "d", ")", "/", "(", "1000000.0", ")", "\n\n", "if", "fs", ".", "Latency", ".", "Current", ">", "fs", ".", "Latency", ".", "Maximum", "{", "fs", ".", "Latency", ".", "Maximum", "=", "fs", ".", "Latency", ".", "Current", "\n", "}", "\n\n", "if", "fs", ".", "Latency", ".", "Current", "<", "fs", ".", "Latency", ".", "Minimum", "{", "fs", ".", "Latency", ".", "Minimum", "=", "fs", ".", "Latency", ".", "Current", "\n", "}", "\n\n", "fs", ".", "Latency", ".", "Average", "=", "(", "total", "+", "fs", ".", "Latency", ".", "Current", ")", "/", "float64", "(", "fs", ".", "Counts", ".", "Success", ")", "\n", "fs", ".", "Latency", ".", "averageSquare", "=", "(", "totalSquare", "+", "fs", ".", "Latency", ".", "Current", "*", "fs", ".", "Latency", ".", "Current", ")", "/", "float64", "(", "fs", ".", "Counts", ".", "Success", ")", "\n\n", "// sdv = sqrt(avg(x^2) - avg(x)^2)", "fs", ".", "Latency", ".", "StandardDeviation", "=", "math", ".", "Sqrt", "(", "fs", ".", "Latency", ".", "averageSquare", "-", "fs", ".", "Latency", ".", "Average", "*", "fs", ".", "Latency", ".", "Average", ")", "\n", "}"], "docstring": "// Succ updates the FollowerStats with a successful send", "docstring_tokens": ["Succ", "updates", "the", "FollowerStats", "with", "a", "successful", "send"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v2stats/leader.go#L97-L121"}, "target": "Succ updates the FollowerStats with a successful send", "arguments": {"gen_args_0": {"arg_0": "func ( fs * FollowerStats ) Succ ( d time . Duration ) { fs . Lock ( ) defer fs . Unlock ( ) total := float64 ( fs . Counts . Success ) * fs . Latency . Average totalSquare := float64 ( fs . Counts . Success ) * fs . Latency . averageSquare fs . Counts . Success ++ fs . Latency . Current = float64 ( d ) / ( 1000000.0 ) if fs . Latency . Current > fs . Latency . Maximum { fs . Latency . Maximum = fs . Latency . Current } if fs . Latency . Current < fs . Latency . Minimum { fs . Latency . Minimum = fs . Latency . Current } fs . Latency . Average = ( total + fs . Latency . Current ) / float64 ( fs . Counts . Success ) fs . Latency . averageSquare = ( totalSquare + fs . Latency . Current * fs . Latency . Current ) / float64 ( fs . Counts . Success ) // sdv = sqrt(avg(x^2) - avg(x)^2) fs . Latency . StandardDeviation = math . Sqrt ( fs . Latency . averageSquare - fs . Latency . Average * fs . Latency . Average ) }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( fs * FollowerStats ) Fail ( d time . Duration ) { fs . Lock ( ) defer fs . Unlock ( ) fs . Counts . Failure ++ fs . Latency . Current = float64 ( d ) / ( 1000000.0 ) if fs . Latency . Current > fs . Latency . Maximum { fs . Latency . Maximum = fs . Latency . Current } if fs . Latency . Current < fs . Latency . Minimum { fs . Latency . Minimum = fs . Latency . Current } fs"]], "filtered_resps": ["func ( fs * FollowerStats ) Fail ( d time . Duration ) { fs . Lock ( ) defer fs . Unlock ( ) fs . Counts . Failure ++ fs . Latency . Current = float64 ( d ) / ( 1000000.0 ) if fs . Latency . Current > fs . Latency . Maximum { fs . Latency . Maximum = fs . Latency . Current } if fs . Latency . Current < fs . Latency . Minimum { fs . Latency . Minimum = fs . Latency . Current } fs"], "doc_hash": "a57dfd563fdf55eafe0a9e6e3912522de14e4236bf4856b642c9b5384abe7160", "prompt_hash": "a861a52c2b0eca8a925c2ab9d6863dc27e893207b9d4c9870e397b4ab1cc8998", "target_hash": "3d53184b104c38bc534fa446ea02318b4d6449d02f12b4ce9321ae949f40f06c", "smoothed_bleu_4": 1.0178480529529224}
{"doc_id": 19, "doc": {"id": 19, "repo": "etcd-io/etcd", "path": "etcdserver/api/v2stats/leader.go", "func_name": "Fail", "original_string": "func (fs *FollowerStats) Fail() {\n\tfs.Lock()\n\tdefer fs.Unlock()\n\tfs.Counts.Fail++\n}", "language": "go", "code": "func (fs *FollowerStats) Fail() {\n\tfs.Lock()\n\tdefer fs.Unlock()\n\tfs.Counts.Fail++\n}", "code_tokens": ["func", "(", "fs", "*", "FollowerStats", ")", "Fail", "(", ")", "{", "fs", ".", "Lock", "(", ")", "\n", "defer", "fs", ".", "Unlock", "(", ")", "\n", "fs", ".", "Counts", ".", "Fail", "++", "\n", "}"], "docstring": "// Fail updates the FollowerStats with an unsuccessful send", "docstring_tokens": ["Fail", "updates", "the", "FollowerStats", "with", "an", "unsuccessful", "send"], "sha": "616592d9ba993e3fe9798eef581316016df98906", "url": "https://github.com/etcd-io/etcd/blob/616592d9ba993e3fe9798eef581316016df98906/etcdserver/api/v2stats/leader.go#L124-L128"}, "target": "Fail updates the FollowerStats with an unsuccessful send", "arguments": {"gen_args_0": {"arg_0": "func ( fs * FollowerStats ) Fail ( ) { fs . Lock ( ) defer fs . Unlock ( ) fs . Counts . Fail ++ }", "arg_1": {"num_beams": 10, "max_gen_toks": 128, "until": ["</s>"]}}}, "resps": [["func ( fs * FollowerStats ) Follow ( ) { fs . Lock ( ) defer fs . Unlock ( ) fs . Counts . Follow ++ } func ( fs * FollowerStats ) Unfollow ( ) { fs . Lock ( ) defer fs . Unlock ( ) fs . Counts . Unfollow ++ } func ( fs * FollowerStats ) Followers ( ) int { fs . Lock ( ) defer fs . Unlock ( ) return fs . Counts . Followers } func ( fs * FollowerStats ) Following ( ) int { fs . Lock ( ) defer"]], "filtered_resps": ["func ( fs * FollowerStats ) Follow ( ) { fs . Lock ( ) defer fs . Unlock ( ) fs . Counts . Follow ++ } func ( fs * FollowerStats ) Unfollow ( ) { fs . Lock ( ) defer fs . Unlock ( ) fs . Counts . Unfollow ++ } func ( fs * FollowerStats ) Followers ( ) int { fs . Lock ( ) defer fs . Unlock ( ) return fs . Counts . Followers } func ( fs * FollowerStats ) Following ( ) int { fs . Lock ( ) defer"], "doc_hash": "fae7470fe2db37bb94c2870874cb2405bf46b8543a90675965e40589a7fc4316", "prompt_hash": "032abb6872f971f1e68886b74459ae62bd9b2292a467f49f1bac3ace0c82ae64", "target_hash": "0c15a1ee5d294e0dc188d11f36548a5c91ca0efc3b02cbe3d570db135f5d29ba", "smoothed_bleu_4": 0.9685543171086303}
